{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AutoMCP","text":"<p>AutoMCP is a toolkit for building Model Control Protocol (MCP) servers from OpenAPI specifications. It enables seamless integration between APIs and Large Language Models (LLMs) like Claude, GPT-4, and others that support the MCP protocol.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>OpenAPI Integration: Convert any API with an OpenAPI specification into an MCP-compatible server</li> <li>Documentation Crawling: Automatically crawl and index API documentation for LLM context</li> <li>MCP Server: Run a compliant MCP server that LLMs can interact with</li> <li>CLI Tools: Manage multiple API servers from a simple command-line interface</li> <li>Prompt Management: Configure and manage prompts for better LLM interactions</li> </ul>"},{"location":"#why-automcp","title":"Why AutoMCP?","text":"<p>AutoMCP makes it easy to expose your API to LLMs by handling:</p> <ul> <li>Standardized API interaction through the MCP protocol</li> <li>Documentation indexing for better context</li> <li>Authentication and rate limiting</li> <li>Prompts and response formatting</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<pre><code># Install AutoMCP\npip install automcp\n\n# Add an API to AutoMCP\nautomcp add --config api_config.json\n\n# Start the MCP server\nautomcp serve\n</code></pre> <p>See the Installation and Getting Started guides for more details.</p>"},{"location":"#how-it-works","title":"How It Works","text":"<ol> <li>AutoMCP parses your OpenAPI specification to understand your API's endpoints</li> <li>It crawls your API documentation to build a searchable knowledge base</li> <li>It sets up an MCP server that exposes your API as tools and resources</li> <li>LLMs can then discover and use your API through the MCP protocol</li> </ol>"},{"location":"#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 OpenAPI     \u2502    \u2502 Documentation\u2502    \u2502 Prompt      \u2502\n\u2502 Processing  \u2502    \u2502 Crawling     \u2502    \u2502 Management  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                   \u2502                  \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502                 \u2502\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502           MCP Server            \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502              LLM                \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>v0.1.2</p>"},{"location":"api/cli/","title":"Command Line Interface","text":"<p>AutoMCP provides a powerful command-line interface (CLI) for managing API configurations, serving MCP endpoints, and integrating with LLMs.</p> <p>Note A dedicated <code>automcp</code> console script may be added in a future release.  For now, invoke the CLI with <code>python -m src.main</code>.</p>"},{"location":"api/cli/#basic-usage","title":"Basic Usage","text":"<pre><code>python -m src.main [command] [options]\n</code></pre>"},{"location":"api/cli/#available-commands","title":"Available Commands","text":"Command Description <code>add</code> Add an API configuration to AutoMCP <code>list-servers</code> List all registered API servers <code>remove</code> Remove an API server from the registry (optionally keep its data) <code>delete</code> (Deprecated) Delete an API server from the registry <code>serve</code> Start the MCP server <code>install</code> Install AutoMCP for specific platforms (e.g., Claude)"},{"location":"api/cli/#command-add","title":"Command: add","text":"<p>The <code>add</code> command processes an API configuration file, crawls its documentation, and registers it with AutoMCP.</p> <pre><code>python -m src.main add --config &lt;path&gt;\n</code></pre>"},{"location":"api/cli/#options","title":"Options","text":"Option Description Default <code>--config</code> Path to API configuration file or directory with JSON configs (required) <code>--db-directory</code> Directory to store the vector database <code>./.chromadb</code> <code>--registry-file</code> Path to the server registry file <code>./automcp_cache/registry.json</code>"},{"location":"api/cli/#examples","title":"Examples","text":"<p>Add a single API: <pre><code>python -m src.main add --config ./ahrefs.json\n</code></pre></p> <p>Add multiple APIs from a directory: <pre><code>python -m src.main add --config ./api_configs/\n</code></pre></p> <p>Specify a custom database directory: <pre><code>python -m src.main add --config ./ahrefs.json --db-directory ./my_db/ahrefs\n</code></pre></p>"},{"location":"api/cli/#command-list-servers","title":"Command: list-servers","text":"<p>The <code>list-servers</code> command displays all registered API servers.</p> <pre><code>python -m src.main list-servers\n</code></pre>"},{"location":"api/cli/#options_1","title":"Options","text":"Option Description Default <code>--registry-file</code> Path to the server registry file <code>./automcp_cache/registry.json</code>"},{"location":"api/cli/#example-output","title":"Example Output","text":"<pre><code>Found 2 registered API server(s):\n\n  - Ahrefs API (config: /path/to/ahrefs.json)\n    Database: /path/to/.chromadb/ahrefs\n    Added: 2023-09-15 14:30:22\n\n  - DataForSEO API (config: /path/to/dataforseo.json)\n    Database: /path/to/.chromadb/dataforseo\n    Added: 2023-09-15 15:45:10\n</code></pre>"},{"location":"api/cli/#command-remove","title":"Command: remove","text":"<p>The <code>remove</code> command removes an API server from the registry and optionally its data.</p> <pre><code>python -m src.main remove --name &lt;server_name&gt;\n</code></pre>"},{"location":"api/cli/#options_2","title":"Options","text":"Option Description Default <code>--name</code> Name of the API server to remove (required) <code>--keep-data</code> Preserve the associated database directory <code>false</code> <code>--registry-file</code> Path to the server registry file <code>./automcp_cache/registry.json</code>"},{"location":"api/cli/#examples_1","title":"Examples","text":"<p>Remove a server and its database: <pre><code>python -m src.main remove --name ahrefs\n</code></pre></p> <p>Remove a server but keep its database: <pre><code>python -m src.main remove --name ahrefs --keep-data\n</code></pre></p>"},{"location":"api/cli/#command-delete","title":"Command: delete","text":"<p>Warning: This command is deprecated and will be removed in a future version. Use <code>remove</code> instead.</p> <p>The <code>delete</code> command removes an API server from the registry (legacy version).</p> <pre><code>python -m src.main delete --name &lt;server_name&gt;\n</code></pre>"},{"location":"api/cli/#options_3","title":"Options","text":"Option Description Default <code>--name</code> Name of the API server to delete (required) <code>--clean</code> Also delete the database directory <code>false</code> <code>--registry-file</code> Path to the server registry file <code>./automcp_cache/registry.json</code>"},{"location":"api/cli/#examples_2","title":"Examples","text":"<p>Delete a server: <pre><code>python -m src.main delete --name ahrefs\n</code></pre></p> <p>Delete a server and its database: <pre><code>python -m src.main delete --name ahrefs --clean\n</code></pre></p>"},{"location":"api/cli/#command-serve","title":"Command: serve","text":"<p>The <code>serve</code> command starts the MCP server for all registered APIs or specified ones.</p> <pre><code>python -m src.main serve [options]\n</code></pre>"},{"location":"api/cli/#options_4","title":"Options","text":"Option Description Default <code>--config</code> Path to API configuration file or directory (optional) Uses registry if not specified <code>--host</code> Host to bind the server to <code>0.0.0.0</code> <code>--port</code> Port to bind the server to <code>8000</code> <code>--debug</code> Enable debug mode <code>false</code> <code>--db-directory</code> Directory to store the vector database <code>./.chromadb</code> <code>--registry-file</code> Path to the server registry file <code>./automcp_cache/registry.json</code>"},{"location":"api/cli/#examples_3","title":"Examples","text":"<p>Start server with all registered APIs: <pre><code>python -m src.main serve\n</code></pre></p> <p>Start server with specific API configuration: <pre><code>python -m src.main serve --config ./ahrefs.json\n</code></pre></p> <p>Start server on a different port: <pre><code>python -m src.main serve --port 9000\n</code></pre></p> <p>Start server in debug mode: <pre><code>python -m src.main serve --debug\n</code></pre></p>"},{"location":"api/cli/#command-install","title":"Command: install","text":"<p>The <code>install</code> command creates configuration files for specific platforms.</p> <pre><code>python -m src.main install &lt;platform&gt; [options]\n</code></pre> <p>Currently supported platforms: - <code>claude</code>: Generate configuration for Claude LLM</p>"},{"location":"api/cli/#options-for-install-claude","title":"Options for <code>install claude</code>","text":"Option Description Default <code>--config</code> Path to API configuration file or directory (optional) Uses registry if not specified <code>--host</code> Host where MCP server is running <code>localhost</code> <code>--port</code> Port where MCP server is running <code>8000</code> <code>--output</code> Path to write Claude configuration file <code>.claude.json</code> <code>--registry-file</code> Path to the server registry file <code>./.automcp_cache/registry.json</code>"},{"location":"api/cli/#examples_4","title":"Examples","text":"<p>Generate Claude configuration for all registered APIs: <pre><code>python -m src.main install claude\n</code></pre></p> <p>Generate Claude configuration for specific APIs: <pre><code>python -m src.main install claude --config ./api_configs/\n</code></pre></p> <p>Specify a custom host and port: <pre><code>python -m src.main install claude --host api.example.com --port 443\n</code></pre></p>"},{"location":"api/documentation/","title":"Documentation Module","text":"<p>Documentation handling module for AutoMCP.</p>"},{"location":"api/documentation/#src.documentation.DocumentationChunk","title":"<code>DocumentationChunk</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A chunk of documentation content for vectorization.</p> Source code in <code>src/documentation/resources.py</code> <pre><code>class DocumentationChunk(BaseModel):\n    \"\"\"A chunk of documentation content for vectorization.\"\"\"\n\n    id: str\n    content: str\n    url: str\n    title: str\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n</code></pre>"},{"location":"api/documentation/#src.documentation.DocumentationCrawler","title":"<code>DocumentationCrawler</code>","text":"<p>Crawler for API documentation using Crawl4AI.</p> Source code in <code>src/documentation/crawler.py</code> <pre><code>class DocumentationCrawler:\n    \"\"\"Crawler for API documentation using Crawl4AI.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str,\n        resource_manager: ResourceManager,\n        max_pages: int = 20,\n        max_depth: int = 3,\n        rate_limit_delay: Optional[Tuple[float, float]] = None,\n        user_agent: str = \"Mozilla/5.0 Documentation Crawler\",\n        chunk_size: int = 500,\n        chunk_overlap: int = 100,\n        bypass_cache: bool = True,\n        remove_nav_elements: bool = False,\n        word_count_threshold: int = 50,\n        rendering: bool = True,\n    ):\n        \"\"\"Initialize the documentation crawler.\n\n        Args:\n            base_url: The base URL for the documentation\n            resource_manager: The resource manager to store crawled content\n            max_pages: Maximum number of pages to crawl\n            max_depth: Maximum depth to crawl\n            rate_limit_delay: Tuple of (min, max) seconds for rate limiting\n            user_agent: User agent to use for requests\n            chunk_size: Size of content chunks for vectorization (in words)\n            chunk_overlap: Overlap between chunks (in words)\n            bypass_cache: Whether to bypass the cache\n            remove_nav_elements: Whether to remove navigation elements from content\n            word_count_threshold: Minimum number of words for a content block to be considered\n            rendering: Whether to enable JavaScript rendering (default: False)\n        \"\"\"\n        self.base_url = base_url\n        self.resource_manager = resource_manager\n        self.max_pages = max_pages\n        self.max_depth = max_depth\n        self.rate_limit_delay = rate_limit_delay\n        self.user_agent = user_agent\n        self.chunk_size = chunk_size\n        self.chunk_overlap = chunk_overlap\n        self.bypass_cache = bypass_cache\n        self.remove_nav_elements = remove_nav_elements\n        self.word_count_threshold = word_count_threshold\n        self.rendering = rendering\n\n        # Parse the base_url to extract the domain for filtering\n        parsed_url = urlparse(base_url)\n        self.base_domain = parsed_url.netloc\n\n    def create_markdown_generator(self) -&gt; DefaultMarkdownGenerator:\n        \"\"\"Create a markdown generator with content filtering.\n\n        Returns:\n            DefaultMarkdownGenerator instance\n        \"\"\"\n        return DefaultMarkdownGenerator(\n            options={\n                \"ignore_links\": False,  # Keep links for reference\n                \"body_width\": 0,  # No wrapping\n                \"escape_html\": True,\n                \"skip_internal_links\": True,  # Skip internal page anchors\n                \"include_sup_sub\": True,  # Better handling of sup/sub elements\n                \"citations\": True,  # Generate citations for links\n            },\n        )\n\n    def create_browser_config(self) -&gt; BrowserConfig:\n        \"\"\"Create a browser configuration.\n\n        Returns:\n            BrowserConfig instance\n        \"\"\"\n        return BrowserConfig(\n            headless=True,\n            user_agent=self.user_agent,\n            viewport_width=1280,\n            viewport_height=800,\n            ignore_https_errors=True,\n            java_script_enabled=self.rendering,\n        )\n\n    def create_crawler_config(self, **kwargs: Any) -&gt; CrawlerRunConfig:\n        \"\"\"Create a crawler configuration with consistent settings.\n\n        Args:\n            **kwargs: Additional configuration parameters to override defaults\n\n        Returns:\n            CrawlerRunConfig instance\n        \"\"\"\n        # Create a markdown generator\n        md_generator = kwargs.pop(\n            \"markdown_generator\", self.create_markdown_generator()\n        )\n\n        # Create filter chain\n        logger.debug(f\"Creating filter chain for {self.base_domain}\")\n        filter_chain = FilterChain(\n            [\n                # Domain boundaries\n                DomainFilter(\n                    allowed_domains=[self.base_domain],\n                ),\n                # Content type filtering\n                ContentTypeFilter(allowed_types=[\"text/html\"]),\n            ]\n        )\n\n        # Use deep crawl strategy unless it's explicitly a single page request\n        crawl_strategy = BestFirstCrawlingStrategy(\n            max_depth=self.max_depth,\n            include_external=False,\n            filter_chain=filter_chain,\n            max_pages=self.max_pages,\n        )\n\n        # Default excluded tags\n        excluded_tags = [\"script\", \"style\", \"iframe\", \"noscript\"]\n        if self.remove_nav_elements:\n            excluded_tags.extend([\"nav\", \"header\", \"footer\"])\n\n        # Override with any tags provided in kwargs\n        if \"excluded_tags\" in kwargs:\n            excluded_tags = kwargs.pop(\"excluded_tags\")\n\n        # Set wait_until based on rendering setting\n        wait_until = kwargs.pop(\n            \"wait_until\", \"networkidle\" if self.rendering else \"domcontentloaded\"\n        )\n\n        # Create base config\n        config = CrawlerRunConfig(\n            markdown_generator=md_generator,\n            excluded_tags=excluded_tags,\n            word_count_threshold=self.word_count_threshold,\n            cache_mode=CacheMode.BYPASS if self.bypass_cache else CacheMode.ENABLED,\n            page_timeout=60000,  # 60 seconds\n            check_robots_txt=True,\n            exclude_external_links=True,\n            exclude_external_images=True,\n            wait_until=wait_until,\n            deep_crawl_strategy=crawl_strategy,\n            **kwargs,  # Additional parameters that override defaults\n        )\n\n        return config\n\n    def chunk_markdown(\n        self, text: str, url: str, title: str\n    ) -&gt; List[DocumentationChunk]:\n        \"\"\"Split markdown content into chunks using Crawl4AI's chunking strategies.\n\n        Args:\n            text: Markdown content to split\n            url: URL of the content\n            title: Title of the content\n\n        Returns:\n            List of document chunks\n        \"\"\"\n        if not text:\n            return []\n\n        try:\n            # Get doc_id by normalizing the URL (removes scheme)\n            doc_id = self.resource_manager.normalize_url(url)\n\n            chunker = SlidingWindowChunking(\n                window_size=self.chunk_size,\n                step=self.chunk_size - self.chunk_overlap,\n            )\n            chunks_text = chunker.chunk(text)\n\n            # Create chunks with metadata\n            chunks = []\n            for i, chunk_text in enumerate(chunks_text):\n                # Skip empty chunks\n                if not chunk_text.strip():\n                    continue\n\n                # Create a unique ID for this chunk using doc_id\n                chunk_id = f\"{doc_id}_{i}\"\n\n                # Create chunk with metadata\n                chunk = DocumentationChunk(\n                    id=chunk_id,\n                    content=chunk_text,\n                    url=url,  # Keep original URL\n                    title=title,\n                    metadata={\n                        \"chunk_index\": i,\n                        \"total_chunks\": len(chunks_text),\n                        \"chunking_method\": chunker.__class__.__name__,\n                        \"doc_id\": doc_id,  # Add doc_id to metadata\n                    },\n                )\n\n                chunks.append(chunk)\n\n            return chunks\n\n        except Exception as e:\n            logger.error(f\"Error chunking markdown: {e}\")\n            return []\n\n    async def crawl_documentation(\n        self, start_url: Optional[str] = None\n    ) -&gt; List[DocumentationResource]:\n        \"\"\"Crawl documentation pages starting from a given URL.\n\n        Args:\n            start_url: The URL to start crawling from (defaults to self.base_url).\n\n        Returns:\n            List of crawled documentation resources.\n        \"\"\"\n        # Determine crawl parameters, using instance defaults if not provided\n        _start_url = start_url or self.base_url\n\n        log_prefix = f\"crawl_documentation(start={_start_url})\"\n        logger.info(f\"{log_prefix}: Starting documentation crawl\")\n\n        # Create browser config\n        browser_config = self.create_browser_config()\n\n        # Track resources\n        resources = []\n\n        # Create crawler\n        async with AsyncWebCrawler(config=browser_config) as crawler:\n            # Configure crawl strategy\n\n            # Create crawler config\n            run_config = self.create_crawler_config(\n                stream=True,\n            )\n\n            # Create dispatcher with rate limiting if needed\n            if self.rate_limit_delay:\n                dispatcher = MemoryAdaptiveDispatcher(\n                    memory_threshold_percent=85.0,\n                    check_interval=1.0,\n                    max_session_permit=10,  # Consider making this configurable\n                    rate_limiter=RateLimiter(\n                        base_delay=self.rate_limit_delay, max_retries=3\n                    ),\n                )\n                logger.debug(\n                    f\"Using memory adaptive dispatcher with rate limiting: {self.rate_limit_delay}\"\n                )\n            else:\n                dispatcher = None\n                logger.debug(\"Using default dispatcher without rate limiting\")\n\n            # Run the crawl\n            logger.info(f\"Running crawl from {_start_url}\")\n\n            try:\n                # Use streaming to process results as they arrive\n                # The arun method handles both single URL and deep crawls based on config\n                async for result in await crawler.arun(\n                    url=_start_url, config=run_config, dispatcher=dispatcher\n                ):\n                    if not result.success:\n                        logger.warning(\n                            f\"Failed to process page {result.url}: {result.error_message}\"\n                        )\n                        continue\n\n                    # Get normalized URL and ensure it's a valid string\n                    normalized_url = self.resource_manager.normalize_url(result.url)\n                    if not isinstance(normalized_url, str) or not normalized_url:\n                        logger.warning(\n                            f\"Skipping result with invalid normalized URL from {result.url}\"\n                        )\n                        continue\n\n                    # Original URL for storing as metadata\n                    original_url = result.url\n\n                    # Extract title, provide default if None or invalid\n                    title = result.metadata.get(\"title\")\n                    if not isinstance(title, str) or not title:\n                        original_title = title  # Keep original for logging\n                        title = f\"Untitled - {normalized_url}\"\n                        logger.warning(\n                            f\"Page {original_url} has invalid title '{original_title}'. Using default: '{title}'\"\n                        )\n                    logger.debug(f\"Processing: {original_url} (Title: {title})\")\n\n                    # Get markdown content from result\n                    if not hasattr(result, \"markdown\") or not result.markdown:\n                        logger.warning(f\"No markdown content for {original_url}\")\n                        continue\n\n                    # Use fit_markdown if available, otherwise use raw_markdown\n                    markdown_content = result.markdown.raw_markdown\n                    fit_markdown = (\n                        getattr(result.markdown, \"fit_markdown\", None)\n                        or markdown_content\n                    )\n\n                    # Skip if content is empty after processing\n                    if not fit_markdown or not fit_markdown.strip():\n                        logger.warning(\n                            f\"Skipping {original_url} due to empty content after processing.\"\n                        )\n                        continue\n\n                    try:\n                        # Create resource\n                        resource = DocumentationResource(\n                            id=normalized_url,\n                            url=original_url,  # Store original URL\n                            title=title,\n                            content=fit_markdown,\n                            metadata={\n                                \"original_url\": original_url,\n                                \"doc_id\": normalized_url,\n                                \"crawled_at\": time.time(),\n                                \"depth\": (\n                                    result.metadata.get(\"depth\", 0)\n                                    if hasattr(result, \"metadata\")\n                                    else 0\n                                ),\n                            },\n                        )\n\n                        # Add resource to list\n                        resources.append(resource)\n\n                        # Add to resource manager (only if not single page? No, RM should handle duplicates)\n                        self.resource_manager.add_resource(resource)\n\n                        # Chunk the content for vector search\n                        chunks = self.chunk_markdown(\n                            fit_markdown, normalized_url, title\n                        )\n\n                        # Add chunks to resource manager\n                        if chunks:\n                            self.resource_manager.add_chunks(chunks)\n                            logger.debug(\n                                f\"Added {len(chunks)} chunks for {normalized_url}\"\n                            )\n\n                        # Log progress\n                        logger.debug(\n                            f\"Successfully processed page: {normalized_url} (Total found: {len(resources)})\"\n                        )\n\n                    except ValidationError as ve:\n                        logger.error(\n                            f\"Pydantic validation failed for {normalized_url}: {ve}\"\n                        )\n                        # Continue to the next page instead of stopping the crawl\n                        continue\n                    except Exception as page_proc_e:\n                        # Catch other unexpected errors during resource/chunk processing\n                        logger.error(\n                            f\"Error processing page data for {normalized_url}: {page_proc_e}\",\n                            exc_info=True,\n                        )\n                        continue\n\n            except Exception as e:\n                # Catch errors during the crawler.arun() call itself\n                logger.error(f\"Fatal error during crawl execution: {e}\", exc_info=True)\n\n        logger.info(\n            f\"{log_prefix}: Crawl finished. Found {len(resources)} documentation pages\"\n        )\n        return resources\n\n    def crawl(self) -&gt; List[DocumentationResource]:\n        \"\"\"Synchronous wrapper for crawl_documentation.\n\n        Returns:\n            List of crawled documentation resources\n        \"\"\"\n        return asyncio.run(self.crawl_documentation())\n</code></pre>"},{"location":"api/documentation/#src.documentation.DocumentationCrawler.__init__","title":"<code>__init__(base_url, resource_manager, max_pages=20, max_depth=3, rate_limit_delay=None, user_agent='Mozilla/5.0 Documentation Crawler', chunk_size=500, chunk_overlap=100, bypass_cache=True, remove_nav_elements=False, word_count_threshold=50, rendering=True)</code>","text":"<p>Initialize the documentation crawler.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL for the documentation</p> required <code>resource_manager</code> <code>ResourceManager</code> <p>The resource manager to store crawled content</p> required <code>max_pages</code> <code>int</code> <p>Maximum number of pages to crawl</p> <code>20</code> <code>max_depth</code> <code>int</code> <p>Maximum depth to crawl</p> <code>3</code> <code>rate_limit_delay</code> <code>Optional[Tuple[float, float]]</code> <p>Tuple of (min, max) seconds for rate limiting</p> <code>None</code> <code>user_agent</code> <code>str</code> <p>User agent to use for requests</p> <code>'Mozilla/5.0 Documentation Crawler'</code> <code>chunk_size</code> <code>int</code> <p>Size of content chunks for vectorization (in words)</p> <code>500</code> <code>chunk_overlap</code> <code>int</code> <p>Overlap between chunks (in words)</p> <code>100</code> <code>bypass_cache</code> <code>bool</code> <p>Whether to bypass the cache</p> <code>True</code> <code>remove_nav_elements</code> <code>bool</code> <p>Whether to remove navigation elements from content</p> <code>False</code> <code>word_count_threshold</code> <code>int</code> <p>Minimum number of words for a content block to be considered</p> <code>50</code> <code>rendering</code> <code>bool</code> <p>Whether to enable JavaScript rendering (default: False)</p> <code>True</code> Source code in <code>src/documentation/crawler.py</code> <pre><code>def __init__(\n    self,\n    base_url: str,\n    resource_manager: ResourceManager,\n    max_pages: int = 20,\n    max_depth: int = 3,\n    rate_limit_delay: Optional[Tuple[float, float]] = None,\n    user_agent: str = \"Mozilla/5.0 Documentation Crawler\",\n    chunk_size: int = 500,\n    chunk_overlap: int = 100,\n    bypass_cache: bool = True,\n    remove_nav_elements: bool = False,\n    word_count_threshold: int = 50,\n    rendering: bool = True,\n):\n    \"\"\"Initialize the documentation crawler.\n\n    Args:\n        base_url: The base URL for the documentation\n        resource_manager: The resource manager to store crawled content\n        max_pages: Maximum number of pages to crawl\n        max_depth: Maximum depth to crawl\n        rate_limit_delay: Tuple of (min, max) seconds for rate limiting\n        user_agent: User agent to use for requests\n        chunk_size: Size of content chunks for vectorization (in words)\n        chunk_overlap: Overlap between chunks (in words)\n        bypass_cache: Whether to bypass the cache\n        remove_nav_elements: Whether to remove navigation elements from content\n        word_count_threshold: Minimum number of words for a content block to be considered\n        rendering: Whether to enable JavaScript rendering (default: False)\n    \"\"\"\n    self.base_url = base_url\n    self.resource_manager = resource_manager\n    self.max_pages = max_pages\n    self.max_depth = max_depth\n    self.rate_limit_delay = rate_limit_delay\n    self.user_agent = user_agent\n    self.chunk_size = chunk_size\n    self.chunk_overlap = chunk_overlap\n    self.bypass_cache = bypass_cache\n    self.remove_nav_elements = remove_nav_elements\n    self.word_count_threshold = word_count_threshold\n    self.rendering = rendering\n\n    # Parse the base_url to extract the domain for filtering\n    parsed_url = urlparse(base_url)\n    self.base_domain = parsed_url.netloc\n</code></pre>"},{"location":"api/documentation/#src.documentation.DocumentationCrawler.chunk_markdown","title":"<code>chunk_markdown(text, url, title)</code>","text":"<p>Split markdown content into chunks using Crawl4AI's chunking strategies.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Markdown content to split</p> required <code>url</code> <code>str</code> <p>URL of the content</p> required <code>title</code> <code>str</code> <p>Title of the content</p> required <p>Returns:</p> Type Description <code>List[DocumentationChunk]</code> <p>List of document chunks</p> Source code in <code>src/documentation/crawler.py</code> <pre><code>def chunk_markdown(\n    self, text: str, url: str, title: str\n) -&gt; List[DocumentationChunk]:\n    \"\"\"Split markdown content into chunks using Crawl4AI's chunking strategies.\n\n    Args:\n        text: Markdown content to split\n        url: URL of the content\n        title: Title of the content\n\n    Returns:\n        List of document chunks\n    \"\"\"\n    if not text:\n        return []\n\n    try:\n        # Get doc_id by normalizing the URL (removes scheme)\n        doc_id = self.resource_manager.normalize_url(url)\n\n        chunker = SlidingWindowChunking(\n            window_size=self.chunk_size,\n            step=self.chunk_size - self.chunk_overlap,\n        )\n        chunks_text = chunker.chunk(text)\n\n        # Create chunks with metadata\n        chunks = []\n        for i, chunk_text in enumerate(chunks_text):\n            # Skip empty chunks\n            if not chunk_text.strip():\n                continue\n\n            # Create a unique ID for this chunk using doc_id\n            chunk_id = f\"{doc_id}_{i}\"\n\n            # Create chunk with metadata\n            chunk = DocumentationChunk(\n                id=chunk_id,\n                content=chunk_text,\n                url=url,  # Keep original URL\n                title=title,\n                metadata={\n                    \"chunk_index\": i,\n                    \"total_chunks\": len(chunks_text),\n                    \"chunking_method\": chunker.__class__.__name__,\n                    \"doc_id\": doc_id,  # Add doc_id to metadata\n                },\n            )\n\n            chunks.append(chunk)\n\n        return chunks\n\n    except Exception as e:\n        logger.error(f\"Error chunking markdown: {e}\")\n        return []\n</code></pre>"},{"location":"api/documentation/#src.documentation.DocumentationCrawler.crawl","title":"<code>crawl()</code>","text":"<p>Synchronous wrapper for crawl_documentation.</p> <p>Returns:</p> Type Description <code>List[DocumentationResource]</code> <p>List of crawled documentation resources</p> Source code in <code>src/documentation/crawler.py</code> <pre><code>def crawl(self) -&gt; List[DocumentationResource]:\n    \"\"\"Synchronous wrapper for crawl_documentation.\n\n    Returns:\n        List of crawled documentation resources\n    \"\"\"\n    return asyncio.run(self.crawl_documentation())\n</code></pre>"},{"location":"api/documentation/#src.documentation.DocumentationCrawler.crawl_documentation","title":"<code>crawl_documentation(start_url=None)</code>  <code>async</code>","text":"<p>Crawl documentation pages starting from a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>start_url</code> <code>Optional[str]</code> <p>The URL to start crawling from (defaults to self.base_url).</p> <code>None</code> <p>Returns:</p> Type Description <code>List[DocumentationResource]</code> <p>List of crawled documentation resources.</p> Source code in <code>src/documentation/crawler.py</code> <pre><code>async def crawl_documentation(\n    self, start_url: Optional[str] = None\n) -&gt; List[DocumentationResource]:\n    \"\"\"Crawl documentation pages starting from a given URL.\n\n    Args:\n        start_url: The URL to start crawling from (defaults to self.base_url).\n\n    Returns:\n        List of crawled documentation resources.\n    \"\"\"\n    # Determine crawl parameters, using instance defaults if not provided\n    _start_url = start_url or self.base_url\n\n    log_prefix = f\"crawl_documentation(start={_start_url})\"\n    logger.info(f\"{log_prefix}: Starting documentation crawl\")\n\n    # Create browser config\n    browser_config = self.create_browser_config()\n\n    # Track resources\n    resources = []\n\n    # Create crawler\n    async with AsyncWebCrawler(config=browser_config) as crawler:\n        # Configure crawl strategy\n\n        # Create crawler config\n        run_config = self.create_crawler_config(\n            stream=True,\n        )\n\n        # Create dispatcher with rate limiting if needed\n        if self.rate_limit_delay:\n            dispatcher = MemoryAdaptiveDispatcher(\n                memory_threshold_percent=85.0,\n                check_interval=1.0,\n                max_session_permit=10,  # Consider making this configurable\n                rate_limiter=RateLimiter(\n                    base_delay=self.rate_limit_delay, max_retries=3\n                ),\n            )\n            logger.debug(\n                f\"Using memory adaptive dispatcher with rate limiting: {self.rate_limit_delay}\"\n            )\n        else:\n            dispatcher = None\n            logger.debug(\"Using default dispatcher without rate limiting\")\n\n        # Run the crawl\n        logger.info(f\"Running crawl from {_start_url}\")\n\n        try:\n            # Use streaming to process results as they arrive\n            # The arun method handles both single URL and deep crawls based on config\n            async for result in await crawler.arun(\n                url=_start_url, config=run_config, dispatcher=dispatcher\n            ):\n                if not result.success:\n                    logger.warning(\n                        f\"Failed to process page {result.url}: {result.error_message}\"\n                    )\n                    continue\n\n                # Get normalized URL and ensure it's a valid string\n                normalized_url = self.resource_manager.normalize_url(result.url)\n                if not isinstance(normalized_url, str) or not normalized_url:\n                    logger.warning(\n                        f\"Skipping result with invalid normalized URL from {result.url}\"\n                    )\n                    continue\n\n                # Original URL for storing as metadata\n                original_url = result.url\n\n                # Extract title, provide default if None or invalid\n                title = result.metadata.get(\"title\")\n                if not isinstance(title, str) or not title:\n                    original_title = title  # Keep original for logging\n                    title = f\"Untitled - {normalized_url}\"\n                    logger.warning(\n                        f\"Page {original_url} has invalid title '{original_title}'. Using default: '{title}'\"\n                    )\n                logger.debug(f\"Processing: {original_url} (Title: {title})\")\n\n                # Get markdown content from result\n                if not hasattr(result, \"markdown\") or not result.markdown:\n                    logger.warning(f\"No markdown content for {original_url}\")\n                    continue\n\n                # Use fit_markdown if available, otherwise use raw_markdown\n                markdown_content = result.markdown.raw_markdown\n                fit_markdown = (\n                    getattr(result.markdown, \"fit_markdown\", None)\n                    or markdown_content\n                )\n\n                # Skip if content is empty after processing\n                if not fit_markdown or not fit_markdown.strip():\n                    logger.warning(\n                        f\"Skipping {original_url} due to empty content after processing.\"\n                    )\n                    continue\n\n                try:\n                    # Create resource\n                    resource = DocumentationResource(\n                        id=normalized_url,\n                        url=original_url,  # Store original URL\n                        title=title,\n                        content=fit_markdown,\n                        metadata={\n                            \"original_url\": original_url,\n                            \"doc_id\": normalized_url,\n                            \"crawled_at\": time.time(),\n                            \"depth\": (\n                                result.metadata.get(\"depth\", 0)\n                                if hasattr(result, \"metadata\")\n                                else 0\n                            ),\n                        },\n                    )\n\n                    # Add resource to list\n                    resources.append(resource)\n\n                    # Add to resource manager (only if not single page? No, RM should handle duplicates)\n                    self.resource_manager.add_resource(resource)\n\n                    # Chunk the content for vector search\n                    chunks = self.chunk_markdown(\n                        fit_markdown, normalized_url, title\n                    )\n\n                    # Add chunks to resource manager\n                    if chunks:\n                        self.resource_manager.add_chunks(chunks)\n                        logger.debug(\n                            f\"Added {len(chunks)} chunks for {normalized_url}\"\n                        )\n\n                    # Log progress\n                    logger.debug(\n                        f\"Successfully processed page: {normalized_url} (Total found: {len(resources)})\"\n                    )\n\n                except ValidationError as ve:\n                    logger.error(\n                        f\"Pydantic validation failed for {normalized_url}: {ve}\"\n                    )\n                    # Continue to the next page instead of stopping the crawl\n                    continue\n                except Exception as page_proc_e:\n                    # Catch other unexpected errors during resource/chunk processing\n                    logger.error(\n                        f\"Error processing page data for {normalized_url}: {page_proc_e}\",\n                        exc_info=True,\n                    )\n                    continue\n\n        except Exception as e:\n            # Catch errors during the crawler.arun() call itself\n            logger.error(f\"Fatal error during crawl execution: {e}\", exc_info=True)\n\n    logger.info(\n        f\"{log_prefix}: Crawl finished. Found {len(resources)} documentation pages\"\n    )\n    return resources\n</code></pre>"},{"location":"api/documentation/#src.documentation.DocumentationCrawler.create_browser_config","title":"<code>create_browser_config()</code>","text":"<p>Create a browser configuration.</p> <p>Returns:</p> Type Description <code>BrowserConfig</code> <p>BrowserConfig instance</p> Source code in <code>src/documentation/crawler.py</code> <pre><code>def create_browser_config(self) -&gt; BrowserConfig:\n    \"\"\"Create a browser configuration.\n\n    Returns:\n        BrowserConfig instance\n    \"\"\"\n    return BrowserConfig(\n        headless=True,\n        user_agent=self.user_agent,\n        viewport_width=1280,\n        viewport_height=800,\n        ignore_https_errors=True,\n        java_script_enabled=self.rendering,\n    )\n</code></pre>"},{"location":"api/documentation/#src.documentation.DocumentationCrawler.create_crawler_config","title":"<code>create_crawler_config(**kwargs)</code>","text":"<p>Create a crawler configuration with consistent settings.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional configuration parameters to override defaults</p> <code>{}</code> <p>Returns:</p> Type Description <code>CrawlerRunConfig</code> <p>CrawlerRunConfig instance</p> Source code in <code>src/documentation/crawler.py</code> <pre><code>def create_crawler_config(self, **kwargs: Any) -&gt; CrawlerRunConfig:\n    \"\"\"Create a crawler configuration with consistent settings.\n\n    Args:\n        **kwargs: Additional configuration parameters to override defaults\n\n    Returns:\n        CrawlerRunConfig instance\n    \"\"\"\n    # Create a markdown generator\n    md_generator = kwargs.pop(\n        \"markdown_generator\", self.create_markdown_generator()\n    )\n\n    # Create filter chain\n    logger.debug(f\"Creating filter chain for {self.base_domain}\")\n    filter_chain = FilterChain(\n        [\n            # Domain boundaries\n            DomainFilter(\n                allowed_domains=[self.base_domain],\n            ),\n            # Content type filtering\n            ContentTypeFilter(allowed_types=[\"text/html\"]),\n        ]\n    )\n\n    # Use deep crawl strategy unless it's explicitly a single page request\n    crawl_strategy = BestFirstCrawlingStrategy(\n        max_depth=self.max_depth,\n        include_external=False,\n        filter_chain=filter_chain,\n        max_pages=self.max_pages,\n    )\n\n    # Default excluded tags\n    excluded_tags = [\"script\", \"style\", \"iframe\", \"noscript\"]\n    if self.remove_nav_elements:\n        excluded_tags.extend([\"nav\", \"header\", \"footer\"])\n\n    # Override with any tags provided in kwargs\n    if \"excluded_tags\" in kwargs:\n        excluded_tags = kwargs.pop(\"excluded_tags\")\n\n    # Set wait_until based on rendering setting\n    wait_until = kwargs.pop(\n        \"wait_until\", \"networkidle\" if self.rendering else \"domcontentloaded\"\n    )\n\n    # Create base config\n    config = CrawlerRunConfig(\n        markdown_generator=md_generator,\n        excluded_tags=excluded_tags,\n        word_count_threshold=self.word_count_threshold,\n        cache_mode=CacheMode.BYPASS if self.bypass_cache else CacheMode.ENABLED,\n        page_timeout=60000,  # 60 seconds\n        check_robots_txt=True,\n        exclude_external_links=True,\n        exclude_external_images=True,\n        wait_until=wait_until,\n        deep_crawl_strategy=crawl_strategy,\n        **kwargs,  # Additional parameters that override defaults\n    )\n\n    return config\n</code></pre>"},{"location":"api/documentation/#src.documentation.DocumentationCrawler.create_markdown_generator","title":"<code>create_markdown_generator()</code>","text":"<p>Create a markdown generator with content filtering.</p> <p>Returns:</p> Type Description <code>DefaultMarkdownGenerator</code> <p>DefaultMarkdownGenerator instance</p> Source code in <code>src/documentation/crawler.py</code> <pre><code>def create_markdown_generator(self) -&gt; DefaultMarkdownGenerator:\n    \"\"\"Create a markdown generator with content filtering.\n\n    Returns:\n        DefaultMarkdownGenerator instance\n    \"\"\"\n    return DefaultMarkdownGenerator(\n        options={\n            \"ignore_links\": False,  # Keep links for reference\n            \"body_width\": 0,  # No wrapping\n            \"escape_html\": True,\n            \"skip_internal_links\": True,  # Skip internal page anchors\n            \"include_sup_sub\": True,  # Better handling of sup/sub elements\n            \"citations\": True,  # Generate citations for links\n        },\n    )\n</code></pre>"},{"location":"api/documentation/#src.documentation.DocumentationResource","title":"<code>DocumentationResource</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A documentation resource for MCP.</p> Source code in <code>src/documentation/resources.py</code> <pre><code>class DocumentationResource(BaseModel):\n    \"\"\"A documentation resource for MCP.\"\"\"\n\n    id: str\n    url: str\n    title: str\n    content: str\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n</code></pre>"},{"location":"api/documentation/#src.documentation.ResourceManager","title":"<code>ResourceManager</code>","text":"<p>Manager for documentation resources and vector search.</p> Source code in <code>src/documentation/resources.py</code> <pre><code>class ResourceManager:\n    \"\"\"Manager for documentation resources and vector search.\"\"\"\n\n    def __init__(\n        self,\n        db_directory: str = DEFAULT_DB_DIRECTORY,\n        embedding_type: str = \"openai\",\n        embedding_model: Optional[str] = None,\n        server_name: str = \"default\",\n    ):\n        \"\"\"Initialize the resource manager.\n\n        Args:\n            db_directory: Directory to store the vector database\n            embedding_type: Type of embedding function to use ('openai' or 'huggingface')\n            embedding_model: Model name to use for embeddings\n            server_name: Name of the server for collection namespacing\n        \"\"\"\n        self.db_directory = db_directory\n        self.server_name = server_name\n        Path(db_directory).mkdir(parents=True, exist_ok=True)\n\n        # Set up ChromaDB client\n        self.client = chromadb.PersistentClient(path=db_directory)\n\n        # Set up embedding function based on type\n        if embedding_type == \"openai\":\n            openai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n            if not openai_api_key:\n                raise ValueError(\n                    \"OPENAI_API_KEY environment variable is required for OpenAI embeddings\"\n                )\n\n            model = embedding_model or DEFAULT_OPENAI_MODEL\n            self.embedding_function = embedding_functions.OpenAIEmbeddingFunction(\n                api_key=openai_api_key, model_name=model\n            )\n        elif embedding_type == \"huggingface\":\n            huggingface_api_key = os.environ.get(\"HUGGINGFACE_API_KEY\")\n\n            model = embedding_model or DEFAULT_SENTENCE_TRANSFORMER_MODEL\n            self.embedding_function = embedding_functions.HuggingFaceEmbeddingFunction(\n                api_key=huggingface_api_key if huggingface_api_key else None,\n                model_name=model,\n            )\n        else:\n            raise ValueError(f\"Unsupported embedding type: {embedding_type}\")\n\n        # Create collections for documents and chunks with server namespacing\n        self.docs_collection = self.client.get_or_create_collection(\n            name=f\"{server_name}_docs\",\n            # default embedding function will be used\n        )\n\n        self.chunks_collection = self.client.get_or_create_collection(\n            name=f\"{server_name}_chunks\", embedding_function=self.embedding_function\n        )\n\n    @staticmethod\n    def normalize_url(url: str) -&gt; str:\n        \"\"\"Normalize a URL by removing scheme, query parameters and fragments.\n\n        This creates a document ID suitable for use in MCP URIs.\n\n        Args:\n            url: The URL to normalize\n\n        Returns:\n            Normalized URL string without scheme\n        \"\"\"\n        parsed = urlparse(url)\n\n        # Create a path that includes netloc and path but no scheme\n        doc_id = parsed.netloc + parsed.path\n\n        # Remove trailing slash if present\n        if doc_id.endswith(\"/\"):\n            doc_id = doc_id[:-1]\n\n        return doc_id\n\n    def add_resource(self, resource: DocumentationResource) -&gt; None:\n        \"\"\"Add a documentation resource to the manager.\n\n        Args:\n            resource: The documentation resource to add\n        \"\"\"\n        # Normalize the URL to use as a canonical ID (without scheme)\n        doc_id = self.normalize_url(resource.url)\n        original_url = resource.url\n\n        # Add to ChromaDB without embeddings\n        try:\n            # Chroma expects *lists* for every field when performing ``upsert``.\n            # The document collection does **not** need real embeddings because it\n            # is used only for look-ups / listing, so we omit the ``embeddings``\n            # argument entirely \u2013 this avoids shape-mismatch errors that were\n            # silently preventing the pages from being stored.\n\n            self.docs_collection.upsert(\n                ids=[doc_id],\n                documents=[resource.content],\n                metadatas=[\n                    {\n                        \"url\": original_url,  # Store the original URL as metadata\n                        \"doc_id\": doc_id,  # Store the doc_id as metadata\n                        \"title\": resource.title,\n                        **resource.metadata,\n                    }\n                ],\n            )\n\n            logger.debug(f\"Added resource to document collection: {doc_id}\")\n        except Exception as e:\n            logger.error(\n                f\"Error adding resource to document collection: {e} in upsert.\"\n            )\n\n    def add_chunks(self, chunks: List[DocumentationChunk]) -&gt; None:\n        \"\"\"Add documentation chunks to the vector database.\n\n        Args:\n            chunks: List of documentation chunks to add\n        \"\"\"\n        # Batch add chunks to ChromaDB\n        try:\n            self.chunks_collection.upsert(\n                ids=[chunk.id for chunk in chunks],\n                documents=[chunk.content for chunk in chunks],\n                metadatas=[\n                    {\n                        \"url\": chunk.url,  # Original URL\n                        \"doc_id\": self.normalize_url(\n                            chunk.url\n                        ),  # Add doc_id to metadata\n                        \"title\": chunk.title,\n                        **chunk.metadata,\n                    }\n                    for chunk in chunks\n                ],\n            )\n            logger.debug(f\"Added {len(chunks)} chunks to vector DB\")\n        except Exception as e:\n            logger.error(f\"Error adding chunks to vector DB: {e}\")\n\n    def get_resource(self, doc_id: str) -&gt; Optional[DocumentationResource]:\n        \"\"\"Get a documentation resource by doc_id.\n\n        Args:\n            doc_id: The document ID (normalized URL without scheme)\n\n        Returns:\n            The documentation resource, or None if not found\n        \"\"\"\n        try:\n            result = self.docs_collection.get(ids=[doc_id])\n            if result and result[\"documents\"] and len(result[\"documents\"]) &gt; 0:\n                metadata = result[\"metadatas\"][0] if result[\"metadatas\"] else {}\n                # Get the original URL from metadata if available\n                original_url = metadata.get(\"url\", \"\")\n\n                return DocumentationResource(\n                    id=doc_id,\n                    url=original_url,\n                    title=metadata.get(\"title\", \"\"),\n                    content=result[\"documents\"][0],\n                    metadata={\n                        k: v\n                        for k, v in metadata.items()\n                        if k not in [\"url\", \"title\", \"doc_id\"]\n                    },\n                )\n        except Exception as e:\n            logger.error(f\"Error retrieving resource: {e}\")\n\n        return None\n\n    def list_resources(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all available documentation resources.\n\n        Returns:\n            List of resource metadata for MCP consumption\n        \"\"\"\n        try:\n            # Get all documents from docs collection\n            results = self.docs_collection.get()\n\n            resources = []\n            for i, doc_id in enumerate(results[\"ids\"]):\n                metadata = results[\"metadatas\"][i] if results[\"metadatas\"] else {}\n                title = metadata.get(\"title\", \"Untitled\")\n\n                # Original URL can be obtained from metadata\n                original_url = metadata.get(\"url\", \"\")\n\n                # Format as MCP resource with proper URI format\n                resources.append(\n                    {\n                        \"uri\": f\"docs://{doc_id}\",\n                        \"name\": title,\n                        \"description\": f\"Documentation page: {title}\",\n                        \"content\": results[\"documents\"][i],\n                        \"metadata\": {\n                            \"original_url\": original_url,\n                            # Include other metadata that might be useful\n                            \"doc_id\": doc_id,\n                        },\n                    }\n                )\n\n            return resources\n        except Exception as e:\n            logger.error(f\"Error listing resources: {e}\")\n            return []\n\n    def search_chunks(self, query: str, limit: int = 5) -&gt; List[Dict[str, Any]]:\n        \"\"\"Search for documentation chunks matching a query.\n\n        Args:\n            query: The search query\n            limit: Maximum number of results to return\n\n        Returns:\n            List of matching chunks\n        \"\"\"\n        try:\n            if not query:\n                return []\n\n            # Search the chunks collection\n            results = self.chunks_collection.query(\n                query_texts=[query],\n                n_results=limit,\n            )\n\n            # Format results for consumption\n            formatted_results = []\n            for i, doc_id in enumerate(results[\"ids\"][0]):\n                metadata = results[\"metadatas\"][0][i] if results[\"metadatas\"] else None\n                if not metadata:\n                    continue\n\n                # Get necessary metadata\n                url = metadata.get(\"url\", \"\")\n                title = metadata.get(\"title\", \"Untitled\")\n                content = results[\"documents\"][0][i]\n\n                # Add to results\n                formatted_results.append(\n                    {\n                        \"id\": doc_id,\n                        \"url\": url,\n                        \"title\": title,\n                        \"content\": content,\n                        \"score\": (\n                            results[\"distances\"][0][i]\n                            if \"distances\" in results\n                            else None\n                        ),\n                    }\n                )\n\n            return formatted_results\n        except Exception as e:\n            logger.error(f\"Error searching chunks: {e}\")\n            return []\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all data in the resource manager.\"\"\"\n        try:\n            # Get collection names for this server\n            docs_collection_name = f\"{self.server_name}_docs\"\n            chunks_collection_name = f\"{self.server_name}_chunks\"\n\n            # Delete collections if they exist\n            try:\n                self.client.delete_collection(docs_collection_name)\n                self.client.delete_collection(chunks_collection_name)\n            except Exception:\n                # Collections might not exist, ignore\n                pass\n\n            # Recreate collections\n            self.docs_collection = self.client.get_or_create_collection(\n                name=docs_collection_name\n            )\n            self.chunks_collection = self.client.get_or_create_collection(\n                name=chunks_collection_name, embedding_function=self.embedding_function\n            )\n\n            logger.info(f\"Cleared all data for server: {self.server_name}\")\n        except Exception as e:\n            logger.error(f\"Error clearing resources: {e}\")\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the resource manager is empty.\n\n        Returns:\n            True if empty, False otherwise\n        \"\"\"\n        try:\n            # Check if docs collection is empty\n            results = self.docs_collection.get()\n            return len(results.get(\"ids\", [])) == 0\n        except Exception:\n            # If there's an error (e.g., collection doesn't exist), consider it empty\n            return True\n\n    def exists(self) -&gt; bool:\n        \"\"\"Check if the database for this resource manager exists.\n\n        Returns:\n            True if the database exists, False otherwise\n        \"\"\"\n        if not os.path.exists(self.db_directory):\n            return False\n\n        try:\n            # Get collection names for this server\n            docs_collection_name = f\"{self.server_name}_docs\"\n            chunks_collection_name = f\"{self.server_name}_chunks\"\n\n            # Check if collections exist in the database\n            return docs_collection_name in [\n                c.name for c in self.client.list_collections()\n            ] and chunks_collection_name in [\n                c.name for c in self.client.list_collections()\n            ]\n        except Exception:\n            # If there's an error accessing the database, consider it doesn't exist\n            return False\n</code></pre>"},{"location":"api/documentation/#src.documentation.ResourceManager.__init__","title":"<code>__init__(db_directory=DEFAULT_DB_DIRECTORY, embedding_type='openai', embedding_model=None, server_name='default')</code>","text":"<p>Initialize the resource manager.</p> <p>Parameters:</p> Name Type Description Default <code>db_directory</code> <code>str</code> <p>Directory to store the vector database</p> <code>DEFAULT_DB_DIRECTORY</code> <code>embedding_type</code> <code>str</code> <p>Type of embedding function to use ('openai' or 'huggingface')</p> <code>'openai'</code> <code>embedding_model</code> <code>Optional[str]</code> <p>Model name to use for embeddings</p> <code>None</code> <code>server_name</code> <code>str</code> <p>Name of the server for collection namespacing</p> <code>'default'</code> Source code in <code>src/documentation/resources.py</code> <pre><code>def __init__(\n    self,\n    db_directory: str = DEFAULT_DB_DIRECTORY,\n    embedding_type: str = \"openai\",\n    embedding_model: Optional[str] = None,\n    server_name: str = \"default\",\n):\n    \"\"\"Initialize the resource manager.\n\n    Args:\n        db_directory: Directory to store the vector database\n        embedding_type: Type of embedding function to use ('openai' or 'huggingface')\n        embedding_model: Model name to use for embeddings\n        server_name: Name of the server for collection namespacing\n    \"\"\"\n    self.db_directory = db_directory\n    self.server_name = server_name\n    Path(db_directory).mkdir(parents=True, exist_ok=True)\n\n    # Set up ChromaDB client\n    self.client = chromadb.PersistentClient(path=db_directory)\n\n    # Set up embedding function based on type\n    if embedding_type == \"openai\":\n        openai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n        if not openai_api_key:\n            raise ValueError(\n                \"OPENAI_API_KEY environment variable is required for OpenAI embeddings\"\n            )\n\n        model = embedding_model or DEFAULT_OPENAI_MODEL\n        self.embedding_function = embedding_functions.OpenAIEmbeddingFunction(\n            api_key=openai_api_key, model_name=model\n        )\n    elif embedding_type == \"huggingface\":\n        huggingface_api_key = os.environ.get(\"HUGGINGFACE_API_KEY\")\n\n        model = embedding_model or DEFAULT_SENTENCE_TRANSFORMER_MODEL\n        self.embedding_function = embedding_functions.HuggingFaceEmbeddingFunction(\n            api_key=huggingface_api_key if huggingface_api_key else None,\n            model_name=model,\n        )\n    else:\n        raise ValueError(f\"Unsupported embedding type: {embedding_type}\")\n\n    # Create collections for documents and chunks with server namespacing\n    self.docs_collection = self.client.get_or_create_collection(\n        name=f\"{server_name}_docs\",\n        # default embedding function will be used\n    )\n\n    self.chunks_collection = self.client.get_or_create_collection(\n        name=f\"{server_name}_chunks\", embedding_function=self.embedding_function\n    )\n</code></pre>"},{"location":"api/documentation/#src.documentation.ResourceManager.add_chunks","title":"<code>add_chunks(chunks)</code>","text":"<p>Add documentation chunks to the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>chunks</code> <code>List[DocumentationChunk]</code> <p>List of documentation chunks to add</p> required Source code in <code>src/documentation/resources.py</code> <pre><code>def add_chunks(self, chunks: List[DocumentationChunk]) -&gt; None:\n    \"\"\"Add documentation chunks to the vector database.\n\n    Args:\n        chunks: List of documentation chunks to add\n    \"\"\"\n    # Batch add chunks to ChromaDB\n    try:\n        self.chunks_collection.upsert(\n            ids=[chunk.id for chunk in chunks],\n            documents=[chunk.content for chunk in chunks],\n            metadatas=[\n                {\n                    \"url\": chunk.url,  # Original URL\n                    \"doc_id\": self.normalize_url(\n                        chunk.url\n                    ),  # Add doc_id to metadata\n                    \"title\": chunk.title,\n                    **chunk.metadata,\n                }\n                for chunk in chunks\n            ],\n        )\n        logger.debug(f\"Added {len(chunks)} chunks to vector DB\")\n    except Exception as e:\n        logger.error(f\"Error adding chunks to vector DB: {e}\")\n</code></pre>"},{"location":"api/documentation/#src.documentation.ResourceManager.add_resource","title":"<code>add_resource(resource)</code>","text":"<p>Add a documentation resource to the manager.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>DocumentationResource</code> <p>The documentation resource to add</p> required Source code in <code>src/documentation/resources.py</code> <pre><code>def add_resource(self, resource: DocumentationResource) -&gt; None:\n    \"\"\"Add a documentation resource to the manager.\n\n    Args:\n        resource: The documentation resource to add\n    \"\"\"\n    # Normalize the URL to use as a canonical ID (without scheme)\n    doc_id = self.normalize_url(resource.url)\n    original_url = resource.url\n\n    # Add to ChromaDB without embeddings\n    try:\n        # Chroma expects *lists* for every field when performing ``upsert``.\n        # The document collection does **not** need real embeddings because it\n        # is used only for look-ups / listing, so we omit the ``embeddings``\n        # argument entirely \u2013 this avoids shape-mismatch errors that were\n        # silently preventing the pages from being stored.\n\n        self.docs_collection.upsert(\n            ids=[doc_id],\n            documents=[resource.content],\n            metadatas=[\n                {\n                    \"url\": original_url,  # Store the original URL as metadata\n                    \"doc_id\": doc_id,  # Store the doc_id as metadata\n                    \"title\": resource.title,\n                    **resource.metadata,\n                }\n            ],\n        )\n\n        logger.debug(f\"Added resource to document collection: {doc_id}\")\n    except Exception as e:\n        logger.error(\n            f\"Error adding resource to document collection: {e} in upsert.\"\n        )\n</code></pre>"},{"location":"api/documentation/#src.documentation.ResourceManager.clear","title":"<code>clear()</code>","text":"<p>Clear all data in the resource manager.</p> Source code in <code>src/documentation/resources.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all data in the resource manager.\"\"\"\n    try:\n        # Get collection names for this server\n        docs_collection_name = f\"{self.server_name}_docs\"\n        chunks_collection_name = f\"{self.server_name}_chunks\"\n\n        # Delete collections if they exist\n        try:\n            self.client.delete_collection(docs_collection_name)\n            self.client.delete_collection(chunks_collection_name)\n        except Exception:\n            # Collections might not exist, ignore\n            pass\n\n        # Recreate collections\n        self.docs_collection = self.client.get_or_create_collection(\n            name=docs_collection_name\n        )\n        self.chunks_collection = self.client.get_or_create_collection(\n            name=chunks_collection_name, embedding_function=self.embedding_function\n        )\n\n        logger.info(f\"Cleared all data for server: {self.server_name}\")\n    except Exception as e:\n        logger.error(f\"Error clearing resources: {e}\")\n</code></pre>"},{"location":"api/documentation/#src.documentation.ResourceManager.exists","title":"<code>exists()</code>","text":"<p>Check if the database for this resource manager exists.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the database exists, False otherwise</p> Source code in <code>src/documentation/resources.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Check if the database for this resource manager exists.\n\n    Returns:\n        True if the database exists, False otherwise\n    \"\"\"\n    if not os.path.exists(self.db_directory):\n        return False\n\n    try:\n        # Get collection names for this server\n        docs_collection_name = f\"{self.server_name}_docs\"\n        chunks_collection_name = f\"{self.server_name}_chunks\"\n\n        # Check if collections exist in the database\n        return docs_collection_name in [\n            c.name for c in self.client.list_collections()\n        ] and chunks_collection_name in [\n            c.name for c in self.client.list_collections()\n        ]\n    except Exception:\n        # If there's an error accessing the database, consider it doesn't exist\n        return False\n</code></pre>"},{"location":"api/documentation/#src.documentation.ResourceManager.get_resource","title":"<code>get_resource(doc_id)</code>","text":"<p>Get a documentation resource by doc_id.</p> <p>Parameters:</p> Name Type Description Default <code>doc_id</code> <code>str</code> <p>The document ID (normalized URL without scheme)</p> required <p>Returns:</p> Type Description <code>Optional[DocumentationResource]</code> <p>The documentation resource, or None if not found</p> Source code in <code>src/documentation/resources.py</code> <pre><code>def get_resource(self, doc_id: str) -&gt; Optional[DocumentationResource]:\n    \"\"\"Get a documentation resource by doc_id.\n\n    Args:\n        doc_id: The document ID (normalized URL without scheme)\n\n    Returns:\n        The documentation resource, or None if not found\n    \"\"\"\n    try:\n        result = self.docs_collection.get(ids=[doc_id])\n        if result and result[\"documents\"] and len(result[\"documents\"]) &gt; 0:\n            metadata = result[\"metadatas\"][0] if result[\"metadatas\"] else {}\n            # Get the original URL from metadata if available\n            original_url = metadata.get(\"url\", \"\")\n\n            return DocumentationResource(\n                id=doc_id,\n                url=original_url,\n                title=metadata.get(\"title\", \"\"),\n                content=result[\"documents\"][0],\n                metadata={\n                    k: v\n                    for k, v in metadata.items()\n                    if k not in [\"url\", \"title\", \"doc_id\"]\n                },\n            )\n    except Exception as e:\n        logger.error(f\"Error retrieving resource: {e}\")\n\n    return None\n</code></pre>"},{"location":"api/documentation/#src.documentation.ResourceManager.is_empty","title":"<code>is_empty()</code>","text":"<p>Check if the resource manager is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if empty, False otherwise</p> Source code in <code>src/documentation/resources.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Check if the resource manager is empty.\n\n    Returns:\n        True if empty, False otherwise\n    \"\"\"\n    try:\n        # Check if docs collection is empty\n        results = self.docs_collection.get()\n        return len(results.get(\"ids\", [])) == 0\n    except Exception:\n        # If there's an error (e.g., collection doesn't exist), consider it empty\n        return True\n</code></pre>"},{"location":"api/documentation/#src.documentation.ResourceManager.list_resources","title":"<code>list_resources()</code>","text":"<p>List all available documentation resources.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of resource metadata for MCP consumption</p> Source code in <code>src/documentation/resources.py</code> <pre><code>def list_resources(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all available documentation resources.\n\n    Returns:\n        List of resource metadata for MCP consumption\n    \"\"\"\n    try:\n        # Get all documents from docs collection\n        results = self.docs_collection.get()\n\n        resources = []\n        for i, doc_id in enumerate(results[\"ids\"]):\n            metadata = results[\"metadatas\"][i] if results[\"metadatas\"] else {}\n            title = metadata.get(\"title\", \"Untitled\")\n\n            # Original URL can be obtained from metadata\n            original_url = metadata.get(\"url\", \"\")\n\n            # Format as MCP resource with proper URI format\n            resources.append(\n                {\n                    \"uri\": f\"docs://{doc_id}\",\n                    \"name\": title,\n                    \"description\": f\"Documentation page: {title}\",\n                    \"content\": results[\"documents\"][i],\n                    \"metadata\": {\n                        \"original_url\": original_url,\n                        # Include other metadata that might be useful\n                        \"doc_id\": doc_id,\n                    },\n                }\n            )\n\n        return resources\n    except Exception as e:\n        logger.error(f\"Error listing resources: {e}\")\n        return []\n</code></pre>"},{"location":"api/documentation/#src.documentation.ResourceManager.normalize_url","title":"<code>normalize_url(url)</code>  <code>staticmethod</code>","text":"<p>Normalize a URL by removing scheme, query parameters and fragments.</p> <p>This creates a document ID suitable for use in MCP URIs.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to normalize</p> required <p>Returns:</p> Type Description <code>str</code> <p>Normalized URL string without scheme</p> Source code in <code>src/documentation/resources.py</code> <pre><code>@staticmethod\ndef normalize_url(url: str) -&gt; str:\n    \"\"\"Normalize a URL by removing scheme, query parameters and fragments.\n\n    This creates a document ID suitable for use in MCP URIs.\n\n    Args:\n        url: The URL to normalize\n\n    Returns:\n        Normalized URL string without scheme\n    \"\"\"\n    parsed = urlparse(url)\n\n    # Create a path that includes netloc and path but no scheme\n    doc_id = parsed.netloc + parsed.path\n\n    # Remove trailing slash if present\n    if doc_id.endswith(\"/\"):\n        doc_id = doc_id[:-1]\n\n    return doc_id\n</code></pre>"},{"location":"api/documentation/#src.documentation.ResourceManager.search_chunks","title":"<code>search_chunks(query, limit=5)</code>","text":"<p>Search for documentation chunks matching a query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query</p> required <code>limit</code> <code>int</code> <p>Maximum number of results to return</p> <code>5</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of matching chunks</p> Source code in <code>src/documentation/resources.py</code> <pre><code>def search_chunks(self, query: str, limit: int = 5) -&gt; List[Dict[str, Any]]:\n    \"\"\"Search for documentation chunks matching a query.\n\n    Args:\n        query: The search query\n        limit: Maximum number of results to return\n\n    Returns:\n        List of matching chunks\n    \"\"\"\n    try:\n        if not query:\n            return []\n\n        # Search the chunks collection\n        results = self.chunks_collection.query(\n            query_texts=[query],\n            n_results=limit,\n        )\n\n        # Format results for consumption\n        formatted_results = []\n        for i, doc_id in enumerate(results[\"ids\"][0]):\n            metadata = results[\"metadatas\"][0][i] if results[\"metadatas\"] else None\n            if not metadata:\n                continue\n\n            # Get necessary metadata\n            url = metadata.get(\"url\", \"\")\n            title = metadata.get(\"title\", \"Untitled\")\n            content = results[\"documents\"][0][i]\n\n            # Add to results\n            formatted_results.append(\n                {\n                    \"id\": doc_id,\n                    \"url\": url,\n                    \"title\": title,\n                    \"content\": content,\n                    \"score\": (\n                        results[\"distances\"][0][i]\n                        if \"distances\" in results\n                        else None\n                    ),\n                }\n            )\n\n        return formatted_results\n    except Exception as e:\n        logger.error(f\"Error searching chunks: {e}\")\n        return []\n</code></pre>"},{"location":"api/main/","title":"Main CLI Module","text":"<p>Name: Command-line interface. Description: Implements the command-line interface for AutoMCP with commands for adding APIs, listing servers, deleting servers, serving MCP instances, and installing for platforms like Claude. Provides a user-friendly way to interact with AutoMCP's core functionality.</p>"},{"location":"api/main/#src.main.add_command","title":"<code>add_command(args)</code>","text":"<p>Add an API configuration to AutoMCP.</p> Source code in <code>src/main.py</code> <pre><code>def add_command(args):\n    \"\"\"Add an API configuration to AutoMCP.\"\"\"\n    registry = ServerRegistry(args.registry_file)\n    config_paths = []\n\n    # Check if a directory was provided\n    if os.path.isdir(args.config):\n        # Find all JSON files in the directory\n        config_paths = glob.glob(os.path.join(args.config, \"*.json\"))\n        logger.debug(f\"Found {len(config_paths)} configuration files in {args.config}\")\n    else:\n        # Assume a single config file was provided\n        config_paths = [args.config]\n\n    for config_path in config_paths:\n        try:\n            # ---------------------------------------------\n            # Load and validate the JSON configuration file\n            # ---------------------------------------------\n\n            api_config = process_config(config_path)\n\n            # --------------------------------------------------\n            # Use the server_name property from ApiConfig\n            # --------------------------------------------------\n            # Fallback to the filename stem only if name is missing\n            server_name = (\n                api_config.server_name or os.path.basename(config_path).split(\".\")[0]\n            )\n\n            # -------------------------------------------\n            # Create a standardized DB directory path\n            # -------------------------------------------\n            # Always use DEFAULT_DB_DIRECTORY/server_name for consistency\n            db_directory = os.path.join(DEFAULT_DB_DIRECTORY, server_name)\n\n            # Initialize resource manager and crawl documentation\n            prepare_resource_manager(api_config, db_directory=db_directory)\n\n            # Register the API using the server_name as the key so that `serve`\n            # can later look it up unambiguously.\n            registry.add_server(server_name, os.path.abspath(config_path), db_directory)\n\n            logger.info(f\"Added and crawled documentation for {api_config.name}\")\n        except Exception as e:\n            logger.error(f\"Error adding API configuration for {config_path}: {e}\")\n</code></pre>"},{"location":"api/main/#src.main.delete_command","title":"<code>delete_command(args)</code>","text":"<p>Delete an API server from AutoMCP.</p> Source code in <code>src/main.py</code> <pre><code>def delete_command(args):\n    \"\"\"Delete an API server from AutoMCP.\"\"\"\n    registry = ServerRegistry(args.registry_file)\n\n    # Get server info before deleting\n    server = registry.get_server(args.name)\n    if not server:\n        logger.error(f\"No server found with name '{args.name}'\")\n        return\n\n    # Delete server from registry\n    success = registry.delete_server(args.name)\n\n    if success:\n        logger.info(f\"Deleted server '{args.name}' from registry\")\n\n        # Optionally delete database directory\n        if (\n            args.clean\n            and server.get(\"db_directory\")\n            and os.path.exists(server[\"db_directory\"])\n        ):\n            try:\n                shutil.rmtree(server[\"db_directory\"])\n                logger.info(f\"Deleted database directory at {server['db_directory']}\")\n            except Exception as e:\n                logger.error(f\"Error deleting database directory: {e}\")\n    else:\n        logger.error(f\"Failed to delete server '{args.name}'\")\n</code></pre>"},{"location":"api/main/#src.main.install_claude_command","title":"<code>install_claude_command(args)</code>","text":"<p>Install AutoMCP for Claude.</p> Source code in <code>src/main.py</code> <pre><code>def install_claude_command(args):\n    \"\"\"Install AutoMCP for Claude.\"\"\"\n    try:\n        registry = ServerRegistry(args.registry_file)\n\n        if args.config:\n            # Use specified config path(s)\n            config_paths = []\n            if os.path.isdir(args.config):\n                # Find all JSON files in the directory\n                config_paths = glob.glob(os.path.join(args.config, \"*.json\"))\n                logger.debug(\n                    f\"Found {len(config_paths)} configuration files in {args.config}\"\n                )\n            else:\n                # Assume a single config file was provided\n                config_paths = [args.config]\n        else:\n            # Use all registered servers\n            config_paths = registry.get_all_config_paths()\n            if not config_paths:\n                logger.error(\n                    \"No registered servers found. Use 'automcp add' to add servers first.\"\n                )\n                return\n\n        # Generate Claude configuration\n        tools = []\n\n        for config_path in config_paths:\n            # Process the configuration to get the server_name consistently\n            api_config = process_config(config_path)\n            server_name = api_config.server_name\n\n            # Add a tool for this API\n            tools.append(\n                {\n                    \"name\": server_name,\n                    \"url\": f\"http://{args.host}:{args.port}/{server_name}/mcp\",\n                    \"schema_version\": \"v1\",\n                }\n            )\n\n        claude_config = {\"tools\": tools}\n\n        # Write Claude configuration\n        with open(args.output, \"w\") as f:\n            json.dump(claude_config, f, indent=2)\n\n        logger.info(f\"Claude configuration successfully written to {args.output}\")\n        logger.debug(\n            f\"To use with Claude, make sure your MCP server is running at {args.host}:{args.port}\"\n        )\n    except Exception as e:\n        logger.error(f\"Error installing for Claude: {e}\")\n        sys.exit(1)\n</code></pre>"},{"location":"api/main/#src.main.list_servers_command","title":"<code>list_servers_command(args)</code>","text":"<p>List all registered API servers.</p> Source code in <code>src/main.py</code> <pre><code>def list_servers_command(args):\n    \"\"\"List all registered API servers.\"\"\"\n    registry = ServerRegistry(args.registry_file)\n    servers = registry.list_servers()\n\n    if not servers:\n        print(\"No API servers registered.\")\n        return\n\n    print(f\"Found {len(servers)} registered API server(s):\")\n    for server in servers:\n        print(f\"  - {server['name']} (config: {server['config_path']})\")\n        print(f\"    Database: {server['db_directory']}\")\n        print(f\"    Added: {server['added_at']}\")\n        print(\"\")\n</code></pre>"},{"location":"api/main/#src.main.main","title":"<code>main()</code>","text":"<p>Main entry point for the CLI.</p> Source code in <code>src/main.py</code> <pre><code>def main():\n    \"\"\"Main entry point for the CLI.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"AutoMCP - Build MCP servers from OpenAPI specs\"\n    )\n    subparsers = parser.add_subparsers(dest=\"command\", help=\"Command to run\")\n\n    def add_registry_file_arg(parser):\n        \"\"\"Add registry file argument to parser.\"\"\"\n        parser.add_argument(\n            \"--registry-file\",\n            type=str,\n            default=DEFAULT_REGISTRY_FILE,\n            help=\"Path to the server registry file\",\n        )\n\n    # Common arguments\n    registry_file_arg = add_registry_file_arg\n\n    # Add command (replaces crawl)\n    add_parser = subparsers.add_parser(\"add\", help=\"Add an API to AutoMCP\")\n    add_parser.add_argument(\n        \"--config\",\n        type=str,\n        required=True,\n        help=\"Path to API configuration file or directory with JSON configs\",\n    )\n    registry_file_arg(add_parser)\n\n    # List servers command\n    list_parser = subparsers.add_parser(\n        \"list-servers\", help=\"List all registered API servers\"\n    )\n    registry_file_arg(list_parser)\n\n    # Replace Delete with Remove command\n    remove_parser = subparsers.add_parser(\n        \"remove\",\n        help=\"Remove an API server configuration and optionally its crawled data\",\n    )\n    remove_parser.add_argument(\n        \"--name\", type=str, required=True, help=\"Name of the API server to remove\"\n    )\n    remove_parser.add_argument(\n        \"--keep-data\",\n        action=\"store_true\",\n        help=\"Prevent deletion of the associated database directory\",\n    )\n    registry_file_arg(remove_parser)\n\n    # Keep the old delete command for backward compatibility (hidden from help)\n    delete_parser = subparsers.add_parser(\"delete\", help=argparse.SUPPRESS)\n    delete_parser.add_argument(\n        \"--name\", type=str, required=True, help=\"Name of the API server to delete\"\n    )\n    delete_parser.add_argument(\n        \"--clean\", action=\"store_true\", help=\"Also delete the database directory\"\n    )\n    registry_file_arg(delete_parser)\n\n    # Serve command\n    serve_parser = subparsers.add_parser(\"serve\", help=\"Start MCP server(s)\")\n    serve_parser.add_argument(\n        \"--config\",\n        type=str,\n        required=False,\n        help=\"Path to API configuration file or directory with JSON configs (optional, uses registry if not specified)\",\n    )\n    serve_parser.add_argument(\n        \"--host\", type=str, default=DEFAULT_HOST, help=\"Host to bind the server to\"\n    )\n    serve_parser.add_argument(\n        \"--port\", type=int, default=DEFAULT_PORT, help=\"Port to bind the server to\"\n    )\n    serve_parser.add_argument(\"--debug\", action=\"store_true\", help=\"Enable debug mode\")\n    registry_file_arg(serve_parser)\n\n    # Install command\n    install_parser = subparsers.add_parser(\n        \"install\", help=\"Install AutoMCP for specific platforms\"\n    )\n    install_subparsers = install_parser.add_subparsers(\n        dest=\"platform\", help=\"Platform to install for\"\n    )\n\n    # Claude install command\n    claude_parser = install_subparsers.add_parser(\"claude\", help=\"Install for Claude\")\n    claude_parser.add_argument(\n        \"--config\",\n        type=str,\n        required=False,\n        help=\"Path to API configuration file or directory with JSON configs (optional, uses registry if not specified)\",\n    )\n    claude_parser.add_argument(\n        \"--host\", type=str, default=\"localhost\", help=\"Host where MCP server is running\"\n    )\n    claude_parser.add_argument(\n        \"--port\",\n        type=int,\n        default=DEFAULT_PORT,\n        help=\"Port where MCP server is running\",\n    )\n    claude_parser.add_argument(\n        \"--output\",\n        type=str,\n        default=\".claude.json\",\n        help=\"Path to write Claude configuration file\",\n    )\n    registry_file_arg(claude_parser)\n\n    args = parser.parse_args()\n\n    # Execute command\n    if args.command == \"add\":\n        add_command(args)\n    elif args.command == \"list-servers\":\n        list_servers_command(args)\n    elif args.command == \"delete\":\n        # For backward compatibility\n        delete_command(args)\n    elif args.command == \"remove\":\n        remove_command(args)\n    elif args.command == \"serve\":\n        serve_command(args)\n    elif args.command == \"install\" and args.platform == \"claude\":\n        install_claude_command(args)\n    else:\n        parser.print_help()\n</code></pre>"},{"location":"api/main/#src.main.remove_command","title":"<code>remove_command(args)</code>","text":"<p>Remove an API server and its data from AutoMCP.</p> Source code in <code>src/main.py</code> <pre><code>def remove_command(args):\n    \"\"\"Remove an API server and its data from AutoMCP.\"\"\"\n    registry = ServerRegistry(args.registry_file)\n\n    # Get server info before removing\n    server = registry.get_server(args.name)\n    if not server:\n        logger.error(f\"No server found with name '{args.name}'\")\n        return\n\n    # Remove server from registry\n    success = registry.delete_server(args.name)\n\n    if success:\n        logger.info(f\"Removed server '{args.name}' from registry\")\n\n        # Always clean up database directory by default unless --keep-data is specified\n        if (\n            not args.keep_data\n            and server.get(\"db_directory\")\n            and os.path.exists(server[\"db_directory\"])\n        ):\n            try:\n                shutil.rmtree(server[\"db_directory\"])\n                logger.info(f\"Removed database directory at {server['db_directory']}\")\n            except Exception as e:\n                logger.error(f\"Error removing database directory: {e}\")\n    else:\n        logger.error(f\"Failed to remove server '{args.name}'\")\n</code></pre>"},{"location":"api/main/#src.main.serve_command","title":"<code>serve_command(args)</code>","text":"<p>Start MCP server(s) for API configuration(s).</p> Source code in <code>src/main.py</code> <pre><code>def serve_command(args):\n    \"\"\"Start MCP server(s) for API configuration(s).\"\"\"\n    registry = ServerRegistry(args.registry_file)\n\n    if args.config:\n        # Use specified config path(s)\n        config_paths = []\n        if os.path.isdir(args.config):\n            # Find all JSON files in the directory\n            config_paths = glob.glob(os.path.join(args.config, \"*.json\"))\n            logger.debug(\n                f\"Found {len(config_paths)} configuration files in {args.config}\"\n            )\n        else:\n            # Assume a single config file was provided\n            config_paths = [args.config]\n    else:\n        # Use all registered servers\n        config_paths = registry.get_all_config_paths()\n        if not config_paths:\n            logger.error(\n                \"No registered servers found. Use 'automcp add' to add servers first.\"\n            )\n            return\n\n    # Start the server with all configs\n    start_mcp_server(\n        config_paths=config_paths,\n        host=args.host,\n        port=args.port,\n        debug=args.debug,\n    )\n</code></pre>"},{"location":"api/manager/","title":"Manager Module","text":"<p>Name: Core functionality manager. Description: Contains core functionality for processing API configurations, generating tools from OpenAPI specs, preparing resource managers with documentation, and starting MCP servers. Orchestrates the different components of AutoMCP to create a complete MCP server.</p>"},{"location":"api/manager/#src.manager.create_mcp_config","title":"<code>create_mcp_config(api_config, resource_manager)</code>","text":"<p>Create an MCP configuration for an API.</p> <p>Parameters:</p> Name Type Description Default <code>api_config</code> <code>ApiConfig</code> <p>API configuration</p> required <code>resource_manager</code> <code>ResourceManager</code> <p>Resource manager with documentation</p> required <p>Returns:</p> Type Description <code>MCPToolsetConfig</code> <p>MCP configuration</p> Source code in <code>src/manager.py</code> <pre><code>def create_mcp_config(\n    api_config: ApiConfig, resource_manager: ResourceManager\n) -&gt; MCPToolsetConfig:\n    \"\"\"Create an MCP configuration for an API.\n\n    Args:\n        api_config: API configuration\n        resource_manager: Resource manager with documentation\n\n    Returns:\n        MCP configuration\n    \"\"\"\n    logger.info(f\"Creating MCP configuration for {api_config.name}\")\n\n    # Generate tools\n    tools = generate_tools(api_config)\n\n    # Get resources\n    resources = {}\n    if resource_manager:\n        # Convert list of resource dicts to a dict keyed by URI\n        resource_list = resource_manager.list_resources()\n        resources = {res[\"uri\"]: res for res in resource_list}\n\n    # Generate prompts\n    prompts = generate_prompts(api_config, tools, resource_manager)\n\n    # Create config\n    return MCPToolsetConfig(\n        name=api_config.name,\n        api_description=api_config.description,\n        tools=tools,\n        resources=resources,\n        prompts=prompts,\n        openapi_spec=api_config.openapi_spec,\n        authentication=api_config.authentication,\n        rate_limits=api_config.rate_limits,\n        retry=api_config.retry,\n    )\n</code></pre>"},{"location":"api/manager/#src.manager.create_mcp_server_from_config_file","title":"<code>create_mcp_server_from_config_file(config_path, host=DEFAULT_HOST, port=DEFAULT_PORT, debug=False, db_directory=DEFAULT_DB_DIRECTORY)</code>","text":"<p>Create an MCP server from a configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str</code> <p>Path to the configuration file</p> required <code>host</code> <code>str</code> <p>Host for the server</p> <code>DEFAULT_HOST</code> <code>port</code> <code>int</code> <p>Port for the server</p> <code>DEFAULT_PORT</code> <code>debug</code> <code>bool</code> <p>Whether to enable debug mode</p> <code>False</code> <code>db_directory</code> <code>str</code> <p>Directory to store the vector database</p> <code>DEFAULT_DB_DIRECTORY</code> <p>Returns:</p> Type Description <code>MCPServer</code> <p>MCP server</p> Source code in <code>src/manager.py</code> <pre><code>def create_mcp_server_from_config_file(\n    config_path: str,\n    host: str = DEFAULT_HOST,\n    port: int = DEFAULT_PORT,\n    debug: bool = False,\n    db_directory: str = DEFAULT_DB_DIRECTORY,\n) -&gt; MCPServer:\n    \"\"\"Create an MCP server from a configuration file.\n\n    Args:\n        config_path: Path to the configuration file\n        host: Host for the server\n        port: Port for the server\n        debug: Whether to enable debug mode\n        db_directory: Directory to store the vector database\n\n    Returns:\n        MCP server\n    \"\"\"\n    # Process the configuration file\n    api_config = process_config(config_path)\n\n    # Determine the server name\n    server_name = api_config.server_name\n\n    # Determine the database directory\n    api_db_directory = os.path.join(db_directory, server_name)\n\n    # Create a resource manager and prepare it with documentation\n    resource_manager = prepare_resource_manager(api_config, api_db_directory)\n\n    # Create MCP config\n    mcp_config = create_mcp_config(api_config, resource_manager)\n\n    # Create and return the server\n    return create_server_from_config(\n        mcp_config=mcp_config,\n        host=host,\n        port=port,\n        debug=debug,\n        db_directory=api_db_directory,\n    )\n</code></pre>"},{"location":"api/manager/#src.manager.generate_prompts","title":"<code>generate_prompts(api_config, tools, resource_manager)</code>","text":"<p>Generate prompts from an API configuration.</p> <p>Parameters:</p> Name Type Description Default <code>api_config</code> <code>ApiConfig</code> <p>API configuration</p> required <code>tools</code> <code>List[Dict]</code> <p>List of tool schemas</p> required <code>resource_manager</code> <code>ResourceManager</code> <p>Resource manager with documentation</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary of prompts</p> Source code in <code>src/manager.py</code> <pre><code>def generate_prompts(\n    api_config: ApiConfig, tools: List[Dict], resource_manager: ResourceManager\n) -&gt; Dict:\n    \"\"\"Generate prompts from an API configuration.\n\n    Args:\n        api_config: API configuration\n        tools: List of tool schemas\n        resource_manager: Resource manager with documentation\n\n    Returns:\n        Dictionary of prompts\n    \"\"\"\n    logger.info(\"Generating prompts\")\n\n    # Get resources from resource manager\n    resources = {}\n    if resource_manager:\n        # Convert list of resource dicts to a dict keyed by URI\n        resource_list = resource_manager.list_resources()\n        resources = {res[\"uri\"]: res for res in resource_list}\n\n    # Create generator\n    generator = PromptGenerator(\n        api_name=api_config.name,\n        api_description=api_config.description,\n        tools=tools,\n        resources=resources,\n        custom_prompts=api_config.prompts,\n    )\n\n    return generator.to_mcp_prompts()\n</code></pre>"},{"location":"api/manager/#src.manager.generate_tools","title":"<code>generate_tools(api_config)</code>","text":"<p>Generate tools from an API configuration.</p> <p>Parameters:</p> Name Type Description Default <code>api_config</code> <code>ApiConfig</code> <p>API configuration</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List of tool schemas</p> Source code in <code>src/manager.py</code> <pre><code>def generate_tools(api_config: ApiConfig) -&gt; List[Dict]:\n    \"\"\"Generate tools from an API configuration.\n\n    Args:\n        api_config: API configuration\n\n    Returns:\n        List of tool schemas\n    \"\"\"\n    logger.info(\"Generating tools from OpenAPI spec\")\n\n    # Create auth config if authentication is provided, otherwise try to discover from spec\n    auth_config = None\n    if api_config.authentication:\n        auth_data = api_config.authentication\n        auth_type = auth_data.get(\"type\")\n\n        if auth_type == \"apiKey\":\n            auth_config = ApiAuthConfig(\n                type=\"apiKey\",\n                in_field=auth_data.get(\"in\"),\n                name=auth_data.get(\"name\"),\n                value=auth_data.get(\"value\", \"\"),\n            )\n        elif auth_type == \"http\":\n            scheme = auth_data.get(\"scheme\")\n            if scheme == \"bearer\":\n                auth_config = ApiAuthConfig(\n                    type=\"http\",\n                    scheme=\"bearer\",\n                    value=auth_data.get(\"value\", \"\"),\n                )\n            elif scheme == \"basic\":\n                username = auth_data.get(\"username\")\n                password = auth_data.get(\"password\")\n                if username and password:\n                    auth_config = ApiAuthConfig(\n                        type=\"http\",\n                        scheme=\"basic\",\n                        username=username,\n                        password=password,\n                        value=f\"{username}:{password}\",\n                    )\n                else:\n                    auth_config = ApiAuthConfig(\n                        type=\"http\",\n                        scheme=\"basic\",\n                        value=auth_data.get(\"value\", \"\"),\n                    )\n        elif auth_type == \"oauth2\":\n            token = auth_data.get(\"value\")\n            auth_config = ApiAuthConfig(\n                type=\"oauth2\",\n                scheme=\"bearer\",  # OAuth2 tokens are typically used as bearer tokens\n                value=token,\n                client_id=auth_data.get(\"client_id\"),\n                client_secret=auth_data.get(\"client_secret\"),\n                token_url=auth_data.get(\"token_url\"),\n                scope=auth_data.get(\"scope\"),\n                auto_refresh=auth_data.get(\"auto_refresh\", False),\n            )\n    elif api_config.openapi_spec:\n        # Try to discover authentication from the OpenAPI spec\n        from .openapi.spec import OpenAPISpecParser\n\n        parser = OpenAPISpecParser(api_config.openapi_spec)\n        security_schemes = parser.get_security_schemes()\n        security_reqs = parser.get_security_requirements()\n\n        if security_reqs and security_schemes:\n            # Use the first security requirement found (simplification)\n            first_req_name = list(security_reqs[0].keys())[0]\n            if first_req_name in security_schemes:\n                scheme_info = security_schemes[first_req_name]\n                scheme_type = scheme_info.get(\"type\")\n                logger.info(\n                    f\"Discovered '{scheme_type}' security scheme '{first_req_name}' from OpenAPI spec.\"\n                )\n\n                if scheme_type == \"apiKey\":\n                    auth_config = ApiAuthConfig(\n                        type=\"apiKey\",\n                        in_field=scheme_info.get(\"in\"),\n                        name=scheme_info.get(\"name\"),\n                        value=\"\",  # User must provide via env var or config\n                    )\n                    logger.warning(\n                        f\"apiKey value for '{scheme_info.get('name')}' must be provided via config or environment variable.\"\n                    )\n                elif scheme_type == \"http\":\n                    http_scheme = scheme_info.get(\"scheme\")\n                    auth_config = ApiAuthConfig(\n                        type=\"http\",\n                        scheme=http_scheme,\n                        value=\"\",  # User must provide via env var or config\n                    )\n                    logger.warning(\n                        f\"Credential value for http '{http_scheme}' auth must be provided via config or environment variable.\"\n                    )\n                # Add other types like oauth2 if needed\n                else:\n                    logger.warning(\n                        f\"Unsupported security scheme type '{scheme_type}' discovered.\"\n                    )\n            else:\n                logger.warning(\n                    f\"Security requirement '{first_req_name}' not found in defined schemes.\"\n                )\n        else:\n            logger.info(\n                \"No authentication information found in config or OpenAPI spec.\"\n            )\n\n    # Create rate limit config if provided\n    rate_limit_config = None\n    if hasattr(api_config, \"rate_limits\") and api_config.rate_limits:\n        rate_limit_config = RateLimitConfig(\n            requests_per_minute=api_config.rate_limits.get(\n                \"per_minute\", DEFAULT_REQUESTS_PER_MINUTE\n            ),\n            requests_per_hour=api_config.rate_limits.get(\"per_hour\"),\n            requests_per_day=api_config.rate_limits.get(\"per_day\"),\n            enabled=api_config.rate_limits.get(\"enabled\", True),\n        )\n\n    # Create retry config if provided\n    retry_config = None\n    if hasattr(api_config, \"retry\") and api_config.retry:\n        retry_config = RetryConfig(\n            max_retries=api_config.retry.get(\"max_retries\", DEFAULT_MAX_RETRIES),\n            backoff_factor=api_config.retry.get(\n                \"backoff_factor\", DEFAULT_BACKOFF_FACTOR\n            ),\n            retry_on_status_codes=api_config.retry.get(\n                \"retry_on_status_codes\", DEFAULT_RETRY_STATUS_CODES\n            ),\n            enabled=api_config.retry.get(\"enabled\", True),\n        )\n\n    # Create toolkit\n    toolkit = OpenAPIToolkit(\n        api_config.openapi_spec,\n        auth_config=auth_config,\n        rate_limit_config=rate_limit_config,\n        retry_config=retry_config,\n    )\n\n    # Get tool schemas\n    return toolkit.get_tool_schemas()\n</code></pre>"},{"location":"api/manager/#src.manager.prepare_resource_manager","title":"<code>prepare_resource_manager(api_config, db_directory)</code>","text":"<p>Prepare a resource manager with crawled documentation.</p> <p>Parameters:</p> Name Type Description Default <code>api_config</code> <code>ApiConfig</code> <p>API configuration</p> required <code>db_directory</code> <code>str</code> <p>Directory to store the vector database</p> required <p>Returns:</p> Type Description <code>ResourceManager</code> <p>ResourceManager instance with crawled documentation</p> Source code in <code>src/manager.py</code> <pre><code>def prepare_resource_manager(\n    api_config: ApiConfig, db_directory: str\n) -&gt; ResourceManager:\n    \"\"\"Prepare a resource manager with crawled documentation.\n\n    Args:\n        api_config: API configuration\n        db_directory: Directory to store the vector database\n\n    Returns:\n        ResourceManager instance with crawled documentation\n    \"\"\"\n    logger.info(\"Preparing resource manager from documentation\")\n\n    # Skip if no documentation URL is provided\n    if not api_config.documentation_url:\n        logger.warning(\"No documentation URL provided, skipping resource preparation\")\n        return None\n\n    # Create a ResourceManager instance\n    resource_manager = ResourceManager(\n        db_directory=db_directory,\n        embedding_type=\"openai\",\n        embedding_model=DEFAULT_EMBEDDING_MODEL,\n        server_name=api_config.server_name,\n    )\n\n    # Crawl documentation if needed\n    if resource_manager.is_empty():\n        logger.info(f\"Crawling documentation from {api_config.documentation_url}\")\n\n        # Set default crawler parameters\n        max_pages = DEFAULT_MAX_PAGES\n        max_depth = DEFAULT_MAX_DEPTH\n        rendering = False\n\n        # Get crawler config from api_config if available\n        if api_config.crawl:\n            # Get rendering setting (default: False if not specified)\n            rendering = api_config.crawl.get(\"rendering\", False)\n\n            # Get max_pages setting (default: 50 if not specified)\n            if \"max_pages\" in api_config.crawl:\n                max_pages = api_config.crawl.get(\"max_pages\")\n\n            # Get max_depth setting (default: 3 if not specified)\n            if \"max_depth\" in api_config.crawl:\n                max_depth = api_config.crawl.get(\"max_depth\")\n\n        crawler = DocumentationCrawler(\n            base_url=api_config.documentation_url,\n            resource_manager=resource_manager,\n            max_pages=max_pages,\n            max_depth=max_depth,\n            rate_limit_delay=DEFAULT_RATE_LIMIT_DELAY,\n            rendering=rendering,\n        )\n        crawler.crawl()\n    else:\n        logger.debug(\"Using existing crawled documentation\")\n\n    return resource_manager\n</code></pre>"},{"location":"api/manager/#src.manager.process_config","title":"<code>process_config(config_path)</code>","text":"<p>Process an API configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str</code> <p>Path to the configuration file</p> required <p>Returns:</p> Type Description <code>ApiConfig</code> <p>API configuration</p> Source code in <code>src/manager.py</code> <pre><code>def process_config(config_path: str) -&gt; ApiConfig:\n    \"\"\"Process an API configuration file.\n\n    Args:\n        config_path: Path to the configuration file\n\n    Returns:\n        API configuration\n    \"\"\"\n    with open(config_path, \"r\") as f:\n        config_data = json.load(f)\n\n    # Process environment variables in authentication before creating the ApiConfig\n    if \"authentication\" in config_data:\n        auth_config = config_data[\"authentication\"]\n\n        # Handle the main auth value\n        if \"value\" in auth_config:\n            auth_config[\"value\"] = substitute_env_vars(auth_config[\"value\"])\n\n        # Also handle username/password if present (for basic auth)\n        if \"username\" in auth_config:\n            auth_config[\"username\"] = substitute_env_vars(auth_config[\"username\"])\n        if \"password\" in auth_config:\n            auth_config[\"password\"] = substitute_env_vars(auth_config[\"password\"])\n\n        # Handle OAuth2 credentials if present\n        if \"client_id\" in auth_config:\n            auth_config[\"client_id\"] = substitute_env_vars(auth_config[\"client_id\"])\n        if \"client_secret\" in auth_config:\n            auth_config[\"client_secret\"] = substitute_env_vars(\n                auth_config[\"client_secret\"]\n            )\n\n    api_config = ApiConfig(**config_data)\n\n    # Load OpenAPI spec if URL is provided\n    if api_config.openapi_spec_url and not api_config.openapi_spec:\n        logger.debug(f\"Loading OpenAPI spec from {api_config.openapi_spec_url}\")\n        api_config.openapi_spec = load_spec_from_url(api_config.openapi_spec_url)\n\n    return api_config\n</code></pre>"},{"location":"api/manager/#src.manager.start_mcp_server","title":"<code>start_mcp_server(config_paths, host=DEFAULT_HOST, port=DEFAULT_PORT, debug=False)</code>","text":"<p>Start an MCP server with multiple API configurations.</p> <p>Parameters:</p> Name Type Description Default <code>config_paths</code> <code>List[str]</code> <p>Paths to API configuration files</p> required <code>host</code> <code>str</code> <p>Host to bind the server to</p> <code>DEFAULT_HOST</code> <code>port</code> <code>int</code> <p>Port to bind the server to</p> <code>DEFAULT_PORT</code> <code>debug</code> <code>bool</code> <p>Whether to enable debug mode</p> <code>False</code> Source code in <code>src/manager.py</code> <pre><code>def start_mcp_server(\n    config_paths: List[str],\n    host: str = DEFAULT_HOST,\n    port: int = DEFAULT_PORT,\n    debug: bool = False,\n):\n    \"\"\"Start an MCP server with multiple API configurations.\n\n    Args:\n        config_paths: Paths to API configuration files\n        host: Host to bind the server to\n        port: Port to bind the server to\n        debug: Whether to enable debug mode\n    \"\"\"\n    from fastapi import FastAPI\n    import uvicorn\n\n    logger.info(\n        f\"Starting MCP server on {host}:{port} with {len(config_paths)} API configs\"\n    )\n\n    # Get server registry for db paths\n    registry = ServerRegistry()\n\n    # Create the main app\n    app = FastAPI(\n        title=\"AutoMCP Server\",\n        description=\"MCP server for multiple APIs\",\n    )\n\n    # Add health check endpoint\n    @app.get(\"/health\")\n    async def health_check():\n        return {\n            \"status\": \"ok\",\n            \"apis\": [os.path.basename(p).split(\".\")[0] for p in config_paths],\n        }\n\n    # Process each config and create MCP handlers\n    for config_path in config_paths:\n        try:\n            # ---------------------------\n            # Load and validate the config\n            # ---------------------------\n\n            api_config = process_config(config_path)\n\n            # Canonical server_name from the ApiConfig\n            server_name = api_config.server_name\n\n            # ------------------------------------------------------\n            # Determine database directory path - always use consistent path\n            # ------------------------------------------------------\n            # Check if there's a registered path in the registry, otherwise create standard path\n            api_db_dir = registry.get_db_directory(server_name) or os.path.join(\n                DEFAULT_DB_DIRECTORY, server_name\n            )\n\n            # --------------------------------------------------\n            # Create a ResourceManager that matches the crawler\n            # --------------------------------------------------\n\n            resource_manager = ResourceManager(\n                db_directory=api_db_dir,\n                embedding_type=\"openai\",\n                embedding_model=DEFAULT_EMBEDDING_MODEL,\n                server_name=server_name,\n            )\n\n            # Skip if resource DB doesn't exist (not crawled during add)\n            if not resource_manager.exists():\n                logger.warning(\n                    f\"No crawled documentation found for {server_name}. Run 'automcp add' first.\"\n                )\n                resource_manager = None\n            else:\n                logger.debug(\n                    f\"Using existing resource manager for {server_name} from {api_db_dir}\"\n                )\n\n            # Create MCP config\n            mcp_config = create_mcp_config(api_config, resource_manager)\n\n            # Create and mount MCP server at /{server_name}/mcp.\n            server = MCPServer(\n                config=mcp_config,\n                host=host,\n                port=port,\n                debug=debug,\n                db_directory=api_db_dir,\n            )\n\n            # Mount the FastMCP SSE sub-application at /{server_name}/mcp.\n            app.mount(f\"/{server_name}/mcp\", server.mcp.sse_app())\n\n            # Add search endpoint if resource manager is available\n            if resource_manager:\n\n                @app.get(f\"/{server_name}/search\")\n                async def search_docs(\n                    query: str,\n                    config_name=server_name,\n                    resource_manager=resource_manager,\n                ):\n                    \"\"\"Search documentation.\"\"\"\n                    results = resource_manager.search_chunks(query)\n                    return {\"results\": results}\n\n            logger.info(\n                f\"Mounted MCP server for {api_config.name} at /{server_name}/mcp\"\n            )\n\n        except Exception as e:\n            logger.error(f\"Error setting up MCP server for {config_path}: {e}\")\n\n    # Start the server\n    uvicorn.run(\n        app,\n        host=host,\n        port=port,\n        log_level=\"warning\",\n    )\n</code></pre>"},{"location":"api/manager/#src.manager.substitute_env_vars","title":"<code>substitute_env_vars(value)</code>","text":"<p>Substitute environment variables in a string using Python's string formatting.</p> <p>Uses the {VAR_NAME} format to reference environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>String potentially containing environment variable references like {VAR_NAME}</p> required <p>Returns:</p> Type Description <code>str</code> <p>String with environment variables substituted</p> Source code in <code>src/manager.py</code> <pre><code>def substitute_env_vars(value: str) -&gt; str:\n    \"\"\"Substitute environment variables in a string using Python's string formatting.\n\n    Uses the {VAR_NAME} format to reference environment variables.\n\n    Args:\n        value: String potentially containing environment variable references like {VAR_NAME}\n\n    Returns:\n        String with environment variables substituted\n    \"\"\"\n    if not value or not isinstance(value, str):\n        return value\n\n    # Only proceed if there are potential variables to substitute\n    if \"{\" not in value:\n        return value\n\n    # Get all environment variables\n    env_vars = dict(os.environ)\n\n    try:\n        # Apply formatting with all environment variables\n        return value.format(**env_vars)\n    except KeyError as e:\n        # Log missing environment variables and leave the value unchanged\n        logger.warning(f\"Environment variable '{e}' referenced in '{value}' not found\")\n        return value\n    except ValueError:\n        # Handle invalid format strings\n        logger.warning(f\"Invalid format string: '{value}'\")\n        return value\n</code></pre>"},{"location":"api/mcp/","title":"MCP Module","text":"<p>MCP server module for AutoMCP.</p>"},{"location":"api/mcp/#src.mcp.MCPServer","title":"<code>MCPServer</code>","text":"<p>MCP Server implementation.</p> Source code in <code>src/mcp/server.py</code> <pre><code>class MCPServer:\n    \"\"\"MCP Server implementation.\"\"\"\n\n    def __init__(\n        self,\n        config: MCPToolsetConfig,\n        host: str = DEFAULT_HOST,\n        port: int = DEFAULT_PORT,\n        debug: bool = False,\n        db_directory: str = DEFAULT_DB_DIRECTORY,\n    ):\n        \"\"\"Initialize an MCP server.\n\n        Args:\n            config: MCP toolset configuration\n            host: Host for the server\n            port: Port for the server\n            debug: Whether to enable debug mode\n            db_directory: Directory to store the vector database\n        \"\"\"\n        self.config = config\n        self.host = host\n        self.port = port\n        self.debug = debug\n        self.db_directory = db_directory\n\n        # Initialize resource manager\n        self.resource_manager = self._create_resource_manager()\n\n        # Create FastMCP instance\n        self.mcp = self._create_mcp_instance()\n\n        # Initialize API toolkit for OpenAPI operations (when needed during execution)\n        self.api_toolkit = None\n\n    def _create_resource_manager(self) -&gt; ResourceManager:\n        \"\"\"Create a resource manager for documentation search.\n\n        Returns:\n            Resource manager\n        \"\"\"\n\n        return ResourceManager(\n            db_directory=self.db_directory,\n            embedding_type=\"openai\",\n            embedding_model=DEFAULT_EMBEDDING_MODEL,\n            server_name=self.config.server_name,\n        )\n\n    def _create_mcp_instance(self) -&gt; FastMCP:\n        \"\"\"Create a FastMCP instance for this server.\n\n        Returns:\n            FastMCP instance\n        \"\"\"\n        # Create FastMCP instance\n        mcp = FastMCP(self.config.name, description=self.config.api_description)\n\n        # Register tools\n        for tool in self.config.tools:\n            tool_name = tool.get(\"name\", \"\")\n            tool_description = tool.get(\"description\", \"\")\n            if not tool_name:\n                continue\n\n            # Create a handler for this tool\n            handler = self._create_tool_handler(tool_name)\n\n            # Register the tool\n            @mcp.tool(name=tool_name, description=tool_description)\n            async def dynamic_tool(handler=handler, **kwargs):  # noqa: D401,E501\n                \"\"\"Dynamic tool handler.\"\"\"\n                return await handler(**kwargs)\n\n        if self.resource_manager:\n\n            @mcp.resource(\"search://{query}\")\n            async def search_docs_resource(query: str, limit: int = 5) -&gt; dict:\n                \"\"\"Search documentation and return results matching the query string.\n\n                Args:\n                    query: The search query text\n                    limit: Maximum number of results to return (default: 5)\n\n                Returns:\n                    Search results with metadata and content snippets\n                \"\"\"\n\n                # Search for documentation chunks\n                results = self.resource_manager.search_chunks(query, limit=limit)\n\n                # Format results for consumption\n                return {\n                    \"query\": query,\n                    \"limit\": limit,\n                    \"count\": len(results),\n                    \"results\": results,\n                }\n\n            @mcp.resource(\"docs://{doc_id}\")\n            async def get_doc_resource(doc_id: str):\n                \"\"\"Return the full text of a crawled documentation page.\"\"\"\n\n                resource = self.resource_manager.get_resource(doc_id)\n                if resource:\n                    return {\n                        \"content\": resource.content,\n                        \"metadata\": {\n                            \"title\": resource.title,\n                            \"url\": resource.url,  # The original HTTP URL\n                            \"doc_id\": doc_id,\n                        },\n                    }\n                return f\"Documentation page '{doc_id}' not found.\"\n\n            # Get the resources list directly from resource_manager\n            resource_list = self.resource_manager.list_resources()\n\n            # Loop through all resources returned by list_resources\n            for resource_data in resource_list:\n                uri = resource_data.get(\"uri\")\n                if uri:\n                    # This is a static resource, register it\n                    logger.debug(f\"Registering static resource: {uri}\")\n                    text_res = TextResource(\n                        uri=uri,\n                        name=resource_data.get(\"name\", \"\"),\n                        description=resource_data.get(\"description\", \"\"),\n                        text=resource_data.get(\"content\", \"\"),\n                    )\n                    mcp.add_resource(text_res)\n\n        # Register prompts\n        for prompt_name, prompt_data in self.config.prompts.items():\n            # Check if prompt_data is a list of messages (conversation prompts)\n            if isinstance(prompt_data, list):\n                # For conversation-style prompts. If the last element is a\n                # dict with a \"description\" key, treat it as metadata.\n                desc = \"\"\n                if prompt_data and isinstance(prompt_data[-1], dict):\n                    desc = prompt_data[-1].get(\"description\", \"\")\n\n                @mcp.prompt(name=prompt_name, description=desc)\n                def prompt_func():\n                    return prompt_data\n\n            else:\n                # For template-style prompts\n                template = prompt_data.get(\"template\", \"\")\n                variables = prompt_data.get(\"variables\", [])\n                description = prompt_data.get(\"description\", \"\")\n\n                if variables:\n                    # For prompts with variables, create a function that takes those variables\n                    # using partial instead of exec for safety\n                    def create_prompt_func(template_str, doc_str):\n                        \"\"\"Create a prompt function with the given template and docstring.\"\"\"\n\n                        def prompt_wrapper(**kwargs):\n                            \"\"\"Wrapper function that will be assigned a dynamic docstring.\"\"\"\n                            return format_template(template_str, **kwargs)\n\n                        # Set the docstring\n                        prompt_wrapper.__doc__ = doc_str\n                        return prompt_wrapper\n\n                    # Create the prompt function\n                    prompt_func = create_prompt_func(\n                        template_str=template, doc_str=f\"Prompt: {description}\"\n                    )\n\n                    # Register with FastMCP\n                    mcp.prompt(name=prompt_name, description=description)(prompt_func)\n                else:\n                    # For simple prompts without variables\n                    @mcp.prompt(name=prompt_name, description=description)\n                    def prompt_func():\n                        \"\"\"Simple prompt without variables.\"\"\"\n                        return template\n\n        return mcp\n\n    def _initialize_api_toolkit(self):\n        \"\"\"Initialise the reusable OpenAPIToolkit instance for this server.\"\"\"\n        if self.api_toolkit is not None:\n            return\n\n        openapi_spec = self.config.openapi_spec or extract_openapi_spec_from_tool(\n            self.config.tools\n        )\n\n        if not openapi_spec:\n            logger.warning(\n                \"Unable to obtain an OpenAPI specification for toolkit initialisation. Falling back to tool reconstruction which may be incomplete.\"\n            )\n            return\n\n        # Map raw config dictionaries (if any) into concrete config models\n        auth_cfg_dict = self.config.authentication or {}\n        rate_cfg_dict = self.config.rate_limits or {}\n        retry_cfg_dict = self.config.retry or {}\n\n        # Construct auth config (if provided)\n        auth_config = None\n        if auth_cfg_dict:\n            auth_type = auth_cfg_dict.get(\"type\")\n            if auth_type == \"apiKey\":\n                auth_config = ApiAuthConfig(\n                    type=\"apiKey\",\n                    in_field=auth_cfg_dict.get(\"in\"),\n                    name=auth_cfg_dict.get(\"name\"),\n                    value=auth_cfg_dict.get(\"value\", \"\"),\n                )\n            elif auth_type == \"http\":\n                scheme = auth_cfg_dict.get(\"scheme\")\n                if scheme == \"bearer\":\n                    auth_config = ApiAuthConfig(\n                        type=\"http\",\n                        scheme=\"bearer\",\n                        value=auth_cfg_dict.get(\"value\", \"\"),\n                    )\n                elif scheme == \"basic\":\n                    username = auth_cfg_dict.get(\"username\")\n                    password = auth_cfg_dict.get(\"password\")\n                    if username and password:\n                        auth_config = ApiAuthConfig(\n                            type=\"http\",\n                            scheme=\"basic\",\n                            username=username,\n                            password=password,\n                            value=f\"{username}:{password}\",\n                        )\n                    else:\n                        auth_config = ApiAuthConfig(\n                            type=\"http\",\n                            scheme=\"basic\",\n                            value=auth_cfg_dict.get(\"value\", \"\"),\n                        )\n            elif auth_type == \"oauth2\":\n                token = auth_cfg_dict.get(\"value\")\n                auth_config = ApiAuthConfig(\n                    type=\"oauth2\",\n                    scheme=\"bearer\",  # OAuth2 tokens are typically used as bearer tokens\n                    value=token,\n                    client_id=auth_cfg_dict.get(\"client_id\"),\n                    client_secret=auth_cfg_dict.get(\"client_secret\"),\n                    token_url=auth_cfg_dict.get(\"token_url\"),\n                    scope=auth_cfg_dict.get(\"scope\"),\n                    auto_refresh=auth_cfg_dict.get(\"auto_refresh\", False),\n                )\n\n        # Construct rate limit config (if provided)\n        rate_limit_config = None\n        if rate_cfg_dict:\n            rate_limit_config = RateLimitConfig(\n                requests_per_minute=rate_cfg_dict.get(\n                    \"per_minute\", DEFAULT_REQUESTS_PER_MINUTE\n                ),\n                requests_per_hour=rate_cfg_dict.get(\"per_hour\"),\n                requests_per_day=rate_cfg_dict.get(\"per_day\"),\n                enabled=rate_cfg_dict.get(\"enabled\", True),\n            )\n\n        # Construct retry config (if provided)\n        retry_config = None\n        if retry_cfg_dict:\n            retry_config = RetryConfig(\n                max_retries=retry_cfg_dict.get(\"max_retries\", DEFAULT_MAX_RETRIES),\n                backoff_factor=retry_cfg_dict.get(\n                    \"backoff_factor\", DEFAULT_BACKOFF_FACTOR\n                ),\n                retry_on_status_codes=retry_cfg_dict.get(\n                    \"retry_on_status_codes\", DEFAULT_RETRY_STATUS_CODES\n                ),\n                enabled=retry_cfg_dict.get(\"enabled\", True),\n            )\n\n        # Create toolkit\n        self.api_toolkit = OpenAPIToolkit(\n            openapi_spec,\n            auth_config=auth_config,\n            rate_limit_config=rate_limit_config,\n            retry_config=retry_config,\n        )\n\n    def _create_tool_handler(self, tool_name: str):\n        \"\"\"Create a handler for a specific tool.\n\n        Args:\n            tool_name: Name of the tool to create a handler for\n\n        Returns:\n            Async function that handles tool execution\n        \"\"\"\n        # Find the tool schema\n        tool_schema = next(\n            (tool for tool in self.config.tools if tool[\"name\"] == tool_name), None\n        )\n        if not tool_schema:\n            raise ValueError(f\"Tool '{tool_name}' not found in configuration\")\n\n        # Create a handler function that will be returned\n        async def handler(**kwargs):\n            \"\"\"Generic handler for tool execution.\"\"\"\n            # Ensure we have a properly initialised API toolkit\n            if self.api_toolkit is None:\n                self._initialize_api_toolkit()\n\n            if self.api_toolkit is None:\n                return {\"error\": \"Unable to initialize API toolkit for tool execution\"}\n\n            # Execute the tool using the toolkit\n            response = await execute_tool(\n                tool_schema=tool_schema,\n                toolkit=self.api_toolkit,\n                parameters=kwargs,\n            )\n            return response\n\n        return handler\n</code></pre>"},{"location":"api/mcp/#src.mcp.MCPServer.__init__","title":"<code>__init__(config, host=DEFAULT_HOST, port=DEFAULT_PORT, debug=False, db_directory=DEFAULT_DB_DIRECTORY)</code>","text":"<p>Initialize an MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>MCPToolsetConfig</code> <p>MCP toolset configuration</p> required <code>host</code> <code>str</code> <p>Host for the server</p> <code>DEFAULT_HOST</code> <code>port</code> <code>int</code> <p>Port for the server</p> <code>DEFAULT_PORT</code> <code>debug</code> <code>bool</code> <p>Whether to enable debug mode</p> <code>False</code> <code>db_directory</code> <code>str</code> <p>Directory to store the vector database</p> <code>DEFAULT_DB_DIRECTORY</code> Source code in <code>src/mcp/server.py</code> <pre><code>def __init__(\n    self,\n    config: MCPToolsetConfig,\n    host: str = DEFAULT_HOST,\n    port: int = DEFAULT_PORT,\n    debug: bool = False,\n    db_directory: str = DEFAULT_DB_DIRECTORY,\n):\n    \"\"\"Initialize an MCP server.\n\n    Args:\n        config: MCP toolset configuration\n        host: Host for the server\n        port: Port for the server\n        debug: Whether to enable debug mode\n        db_directory: Directory to store the vector database\n    \"\"\"\n    self.config = config\n    self.host = host\n    self.port = port\n    self.debug = debug\n    self.db_directory = db_directory\n\n    # Initialize resource manager\n    self.resource_manager = self._create_resource_manager()\n\n    # Create FastMCP instance\n    self.mcp = self._create_mcp_instance()\n\n    # Initialize API toolkit for OpenAPI operations (when needed during execution)\n    self.api_toolkit = None\n</code></pre>"},{"location":"api/mcp/#src.mcp.MCPToolsetConfig","title":"<code>MCPToolsetConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for an MCP toolset.</p> Source code in <code>src/mcp/config.py</code> <pre><code>class MCPToolsetConfig(BaseModel):\n    \"\"\"Configuration for an MCP toolset.\"\"\"\n\n    name: str\n    api_description: str\n    tools: List[Dict]\n    resources: Dict\n    prompts: Dict\n\n    # --- Runtime metadata (optional) ---\n    # Keeping these in the config means we do not have to try to reverse-engineer\n    # them later when a tool is actually executed.\n    openapi_spec: Optional[Dict] = None\n    authentication: Optional[Dict] = None  # Raw auth section from the ApiConfig\n    rate_limits: Optional[Dict] = None  # Raw rate-limit section from the ApiConfig\n    retry: Optional[Dict] = None  # Raw retry section from the ApiConfig\n\n    @property\n    def server_name(self) -&gt; str:\n        \"\"\"Get the standardized server name (lowercase with underscores).\n\n        Returns:\n            Standardized server name for use in URLs and file paths\n        \"\"\"\n        return self.name.lower().replace(\" \", \"_\") if self.name else \"\" \n</code></pre>"},{"location":"api/mcp/#src.mcp.MCPToolsetConfig.server_name","title":"<code>server_name: str</code>  <code>property</code>","text":"<p>Get the standardized server name (lowercase with underscores).</p> <p>Returns:</p> Type Description <code>str</code> <p>Standardized server name for use in URLs and file paths</p>"},{"location":"api/mcp/#src.mcp.create_server_from_config","title":"<code>create_server_from_config(mcp_config, host=DEFAULT_HOST, port=DEFAULT_PORT, debug=False, db_directory=DEFAULT_DB_DIRECTORY)</code>","text":"<p>Create an MCP server from a configuration object.</p> <p>Parameters:</p> Name Type Description Default <code>mcp_config</code> <code>MCPToolsetConfig</code> <p>MCP toolset configuration object</p> required <code>host</code> <code>str</code> <p>Host for the server</p> <code>DEFAULT_HOST</code> <code>port</code> <code>int</code> <p>Port for the server</p> <code>DEFAULT_PORT</code> <code>debug</code> <code>bool</code> <p>Whether to enable debug mode</p> <code>False</code> <code>db_directory</code> <code>str</code> <p>Directory to store the vector database</p> <code>DEFAULT_DB_DIRECTORY</code> <p>Returns:</p> Type Description <code>MCPServer</code> <p>MCP server</p> Source code in <code>src/mcp/server.py</code> <pre><code>def create_server_from_config(\n    mcp_config: MCPToolsetConfig,\n    host: str = DEFAULT_HOST,\n    port: int = DEFAULT_PORT,\n    debug: bool = False,\n    db_directory: str = DEFAULT_DB_DIRECTORY,\n) -&gt; \"MCPServer\":\n    \"\"\"Create an MCP server from a configuration object.\n\n    Args:\n        mcp_config: MCP toolset configuration object\n        host: Host for the server\n        port: Port for the server\n        debug: Whether to enable debug mode\n        db_directory: Directory to store the vector database\n\n    Returns:\n        MCP server\n    \"\"\"\n    # Create and return the server\n    return MCPServer(\n        config=mcp_config,\n        host=host,\n        port=port,\n        debug=debug,\n        db_directory=db_directory,\n    )\n</code></pre>"},{"location":"api/openapi/","title":"OpenAPI Module","text":"<p>OpenAPI handling module for AutoMCP.</p>"},{"location":"api/openapi/#src.openapi.ApiAuthConfig","title":"<code>ApiAuthConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Authentication configuration for an API.</p> Source code in <code>src/openapi/models.py</code> <pre><code>class ApiAuthConfig(BaseModel):\n    \"\"\"Authentication configuration for an API.\"\"\"\n\n    type: str  # apiKey, http, oauth2, openIdConnect\n    in_field: Optional[str] = None  # header, query\n    name: Optional[str] = None\n    scheme: Optional[str] = None  # bearer, basic\n    value: Optional[str] = None  # actual credential\n\n    # Additional fields for HTTP Basic auth\n    username: Optional[str] = None\n    password: Optional[str] = None\n\n    # Additional fields for OAuth2\n    client_id: Optional[str] = None\n    client_secret: Optional[str] = None\n    token_url: Optional[str] = None\n    scope: Optional[str] = None\n    auto_refresh: bool = False  # Whether to automatically refresh tokens\n</code></pre>"},{"location":"api/openapi/#src.openapi.ApiEndpoint","title":"<code>ApiEndpoint</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Endpoint for an API request.</p> Source code in <code>src/openapi/models.py</code> <pre><code>class ApiEndpoint(BaseModel):\n    \"\"\"Endpoint for an API request.\"\"\"\n\n    operation_id: str\n    method: str  # get, post\n    path: str\n    summary: str = \"\"\n    description: str = \"\"\n    parameters: List[ApiParameter] = []\n    response_schema: Optional[Dict[str, Any]] = None\n    request_body: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/openapi/#src.openapi.ApiParameter","title":"<code>ApiParameter</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameter for an API request.</p> Source code in <code>src/openapi/models.py</code> <pre><code>class ApiParameter(BaseModel):\n    \"\"\"Parameter for an API request.\"\"\"\n\n    name: str\n    description: str = \"\"\n    required: bool = False\n    location: str  # path, query, header, cookie, body\n    schema_definition: Dict[str, Any] = Field(default={})\n</code></pre>"},{"location":"api/openapi/#src.openapi.OpenAPISpecParser","title":"<code>OpenAPISpecParser</code>","text":"<p>Parser for OpenAPI specifications.</p> Source code in <code>src/openapi/spec.py</code> <pre><code>class OpenAPISpecParser:\n    \"\"\"Parser for OpenAPI specifications.\"\"\"\n\n    def __init__(self, spec: Dict[str, Any]):\n        \"\"\"Initialize the parser with an OpenAPI spec.\n\n        Args:\n            spec: The OpenAPI spec as a dictionary\n        \"\"\"\n        self.spec = spec\n        self.reduced_spec = reduce_openapi_spec(spec)\n\n    def get_base_url(self) -&gt; str:\n        \"\"\"Get the base URL from the OpenAPI spec.\n\n        Returns:\n            The base URL for API requests\n        \"\"\"\n        if not self.reduced_spec.servers:\n            return \"\"\n\n        # Use the first server URL\n        server = self.reduced_spec.servers[0]\n        url = server.get(\"url\", \"\")\n\n        # Remove trailing slash if present\n        if url.endswith(\"/\"):\n            url = url[:-1]\n\n        return url\n\n    def get_endpoints(self) -&gt; List[Tuple[str, str, Dict[str, Any]]]:\n        \"\"\"Get all endpoints from the OpenAPI spec.\n\n        Returns:\n            A list of endpoints with their descriptions\n        \"\"\"\n        return self.reduced_spec.endpoints\n\n    def get_auth_schemes(self) -&gt; Dict[str, Any]:\n        \"\"\"Get authentication schemes from the OpenAPI spec.\n\n        Returns:\n            A dictionary of authentication schemes\n        \"\"\"\n        components = self.spec.get(\"components\", {})\n        security_schemes = components.get(\"securitySchemes\", {})\n        return security_schemes\n\n    def get_security_schemes(self) -&gt; Dict[str, Any]:\n        \"\"\"Extract security schemes defined in the specification.\n\n        Returns:\n            Dictionary of security schemes keyed by name\n        \"\"\"\n        return self.spec.get(\"components\", {}).get(\"securitySchemes\", {})\n\n    def get_security_requirements(self) -&gt; List[Dict[str, List[str]]]:\n        \"\"\"Extract global security requirements defined in the specification.\n\n        Returns:\n            List of security requirement objects\n        \"\"\"\n        return self.spec.get(\"security\", [])\n</code></pre>"},{"location":"api/openapi/#src.openapi.OpenAPISpecParser.__init__","title":"<code>__init__(spec)</code>","text":"<p>Initialize the parser with an OpenAPI spec.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>Dict[str, Any]</code> <p>The OpenAPI spec as a dictionary</p> required Source code in <code>src/openapi/spec.py</code> <pre><code>def __init__(self, spec: Dict[str, Any]):\n    \"\"\"Initialize the parser with an OpenAPI spec.\n\n    Args:\n        spec: The OpenAPI spec as a dictionary\n    \"\"\"\n    self.spec = spec\n    self.reduced_spec = reduce_openapi_spec(spec)\n</code></pre>"},{"location":"api/openapi/#src.openapi.OpenAPISpecParser.get_auth_schemes","title":"<code>get_auth_schemes()</code>","text":"<p>Get authentication schemes from the OpenAPI spec.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary of authentication schemes</p> Source code in <code>src/openapi/spec.py</code> <pre><code>def get_auth_schemes(self) -&gt; Dict[str, Any]:\n    \"\"\"Get authentication schemes from the OpenAPI spec.\n\n    Returns:\n        A dictionary of authentication schemes\n    \"\"\"\n    components = self.spec.get(\"components\", {})\n    security_schemes = components.get(\"securitySchemes\", {})\n    return security_schemes\n</code></pre>"},{"location":"api/openapi/#src.openapi.OpenAPISpecParser.get_base_url","title":"<code>get_base_url()</code>","text":"<p>Get the base URL from the OpenAPI spec.</p> <p>Returns:</p> Type Description <code>str</code> <p>The base URL for API requests</p> Source code in <code>src/openapi/spec.py</code> <pre><code>def get_base_url(self) -&gt; str:\n    \"\"\"Get the base URL from the OpenAPI spec.\n\n    Returns:\n        The base URL for API requests\n    \"\"\"\n    if not self.reduced_spec.servers:\n        return \"\"\n\n    # Use the first server URL\n    server = self.reduced_spec.servers[0]\n    url = server.get(\"url\", \"\")\n\n    # Remove trailing slash if present\n    if url.endswith(\"/\"):\n        url = url[:-1]\n\n    return url\n</code></pre>"},{"location":"api/openapi/#src.openapi.OpenAPISpecParser.get_endpoints","title":"<code>get_endpoints()</code>","text":"<p>Get all endpoints from the OpenAPI spec.</p> <p>Returns:</p> Type Description <code>List[Tuple[str, str, Dict[str, Any]]]</code> <p>A list of endpoints with their descriptions</p> Source code in <code>src/openapi/spec.py</code> <pre><code>def get_endpoints(self) -&gt; List[Tuple[str, str, Dict[str, Any]]]:\n    \"\"\"Get all endpoints from the OpenAPI spec.\n\n    Returns:\n        A list of endpoints with their descriptions\n    \"\"\"\n    return self.reduced_spec.endpoints\n</code></pre>"},{"location":"api/openapi/#src.openapi.OpenAPISpecParser.get_security_requirements","title":"<code>get_security_requirements()</code>","text":"<p>Extract global security requirements defined in the specification.</p> <p>Returns:</p> Type Description <code>List[Dict[str, List[str]]]</code> <p>List of security requirement objects</p> Source code in <code>src/openapi/spec.py</code> <pre><code>def get_security_requirements(self) -&gt; List[Dict[str, List[str]]]:\n    \"\"\"Extract global security requirements defined in the specification.\n\n    Returns:\n        List of security requirement objects\n    \"\"\"\n    return self.spec.get(\"security\", [])\n</code></pre>"},{"location":"api/openapi/#src.openapi.OpenAPISpecParser.get_security_schemes","title":"<code>get_security_schemes()</code>","text":"<p>Extract security schemes defined in the specification.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of security schemes keyed by name</p> Source code in <code>src/openapi/spec.py</code> <pre><code>def get_security_schemes(self) -&gt; Dict[str, Any]:\n    \"\"\"Extract security schemes defined in the specification.\n\n    Returns:\n        Dictionary of security schemes keyed by name\n    \"\"\"\n    return self.spec.get(\"components\", {}).get(\"securitySchemes\", {})\n</code></pre>"},{"location":"api/openapi/#src.openapi.OpenAPIToolkit","title":"<code>OpenAPIToolkit</code>","text":"<p>Toolkit for creating tools from an OpenAPI specification.</p> Source code in <code>src/openapi/tools.py</code> <pre><code>class OpenAPIToolkit:\n    \"\"\"Toolkit for creating tools from an OpenAPI specification.\"\"\"\n\n    def __init__(\n        self,\n        spec: Dict[str, Any],\n        auth_config: Optional[ApiAuthConfig] = None,\n        rate_limit_config: Optional[RateLimitConfig] = None,\n        retry_config: Optional[RetryConfig] = None,\n        pagination_config: Optional[PaginationConfig] = None,\n    ):\n        \"\"\"Initialize an OpenAPI toolkit.\n\n        Args:\n            spec: OpenAPI specification as a dictionary\n            auth_config: Authentication configuration\n            rate_limit_config: Rate limiting configuration\n            retry_config: Retry configuration\n            pagination_config: Pagination configuration\n        \"\"\"\n        self.spec_parser = OpenAPISpecParser(spec)\n        self.base_url = self.spec_parser.get_base_url()\n        self.auth_config = auth_config\n        self.rate_limit_config = rate_limit_config\n        self.retry_config = retry_config\n        self.pagination_config = pagination_config\n        self.tools = self._create_tools()\n\n    def _create_tools(self) -&gt; List[RestApiTool]:\n        \"\"\"Create tools from the OpenAPI specification.\n\n        Returns:\n            List of REST API tools\n        \"\"\"\n        tools = []\n        endpoints = self.spec_parser.get_endpoints()\n\n        for name, description, endpoint_spec in endpoints:\n            method = name.split(\" \", 1)[0].lower()\n\n            # Only support GET and POST methods as per guidelines\n            if method not in [\"get\", \"post\"]:\n                logger.debug(\n                    f\"Skipping endpoint {name} as method '{method}' is not supported.\"\n                )\n                continue\n\n            # Extract operation ID to use as a unique tool name\n            operation_id = endpoint_spec.get(\"operationId\")\n            if not operation_id:\n                # Generate an operation ID if not provided\n                method, path = name.split(\" \", 1)\n                operation_id = f\"{method.lower()}_{path.replace('/', '_').replace('{', '').replace('}', '')}\"\n\n            # Clean up path parameters\n            path = name.split(\" \", 1)[1]\n\n            # Extract and transform parameters\n            parameters = []\n            for param_spec in endpoint_spec.get(\"parameters\", []):\n                param = ApiParameter(\n                    name=param_spec[\"name\"],\n                    description=param_spec.get(\"description\", \"\"),\n                    required=param_spec.get(\"required\", False),\n                    location=param_spec[\"in\"],\n                    schema_definition=param_spec.get(\"schema\", {}),\n                )\n                parameters.append(param)\n\n            # Extract request body if present\n            request_body = None\n            if \"requestBody\" in endpoint_spec:\n                request_body = endpoint_spec[\"requestBody\"]\n\n            # Extract response schema if present\n            response_schema = None\n            if \"responses\" in endpoint_spec and \"200\" in endpoint_spec[\"responses\"]:\n                response_schema = endpoint_spec[\"responses\"][\"200\"].get(\"schema\")\n\n            # Create an ApiEndpoint object\n            api_endpoint = ApiEndpoint(\n                operation_id=operation_id,\n                method=method,\n                path=path,\n                summary=endpoint_spec.get(\"summary\", \"\"),\n                description=endpoint_spec.get(\"description\", \"\"),\n                parameters=parameters,\n                request_body=request_body,\n                response_schema=response_schema,\n            )\n\n            # Create a RestApiTool\n            tool = RestApiTool(\n                name=operation_id,\n                description=description or endpoint_spec.get(\"summary\", \"\"),\n                endpoint=api_endpoint,\n                base_url=self.base_url,\n                auth_config=self.auth_config,\n                rate_limit_config=self.rate_limit_config,\n                retry_config=self.retry_config,\n                pagination_config=self.pagination_config,\n            )\n\n            tools.append(tool)\n\n        return tools\n\n    def get_tools(self) -&gt; List[RestApiTool]:\n        \"\"\"Get all tools from the toolkit.\n\n        Returns:\n            A list of REST API tools\n        \"\"\"\n        return self.tools\n\n    def get_tool(self, name: str) -&gt; Optional[RestApiTool]:\n        \"\"\"Get a tool by name.\n\n        Args:\n            name: Name of the tool\n\n        Returns:\n            The tool if found, None otherwise\n        \"\"\"\n        for tool in self.tools:\n            if tool.name == name:\n                return tool\n        return None\n\n    def get_tool_schemas(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get schemas for all tools.\n\n        Returns:\n            A list of tool schemas\n        \"\"\"\n        return [tool.to_schema() for tool in self.tools]\n</code></pre>"},{"location":"api/openapi/#src.openapi.OpenAPIToolkit.__init__","title":"<code>__init__(spec, auth_config=None, rate_limit_config=None, retry_config=None, pagination_config=None)</code>","text":"<p>Initialize an OpenAPI toolkit.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>Dict[str, Any]</code> <p>OpenAPI specification as a dictionary</p> required <code>auth_config</code> <code>Optional[ApiAuthConfig]</code> <p>Authentication configuration</p> <code>None</code> <code>rate_limit_config</code> <code>Optional[RateLimitConfig]</code> <p>Rate limiting configuration</p> <code>None</code> <code>retry_config</code> <code>Optional[RetryConfig]</code> <p>Retry configuration</p> <code>None</code> <code>pagination_config</code> <code>Optional[PaginationConfig]</code> <p>Pagination configuration</p> <code>None</code> Source code in <code>src/openapi/tools.py</code> <pre><code>def __init__(\n    self,\n    spec: Dict[str, Any],\n    auth_config: Optional[ApiAuthConfig] = None,\n    rate_limit_config: Optional[RateLimitConfig] = None,\n    retry_config: Optional[RetryConfig] = None,\n    pagination_config: Optional[PaginationConfig] = None,\n):\n    \"\"\"Initialize an OpenAPI toolkit.\n\n    Args:\n        spec: OpenAPI specification as a dictionary\n        auth_config: Authentication configuration\n        rate_limit_config: Rate limiting configuration\n        retry_config: Retry configuration\n        pagination_config: Pagination configuration\n    \"\"\"\n    self.spec_parser = OpenAPISpecParser(spec)\n    self.base_url = self.spec_parser.get_base_url()\n    self.auth_config = auth_config\n    self.rate_limit_config = rate_limit_config\n    self.retry_config = retry_config\n    self.pagination_config = pagination_config\n    self.tools = self._create_tools()\n</code></pre>"},{"location":"api/openapi/#src.openapi.OpenAPIToolkit.get_tool","title":"<code>get_tool(name)</code>","text":"<p>Get a tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tool</p> required <p>Returns:</p> Type Description <code>Optional[RestApiTool]</code> <p>The tool if found, None otherwise</p> Source code in <code>src/openapi/tools.py</code> <pre><code>def get_tool(self, name: str) -&gt; Optional[RestApiTool]:\n    \"\"\"Get a tool by name.\n\n    Args:\n        name: Name of the tool\n\n    Returns:\n        The tool if found, None otherwise\n    \"\"\"\n    for tool in self.tools:\n        if tool.name == name:\n            return tool\n    return None\n</code></pre>"},{"location":"api/openapi/#src.openapi.OpenAPIToolkit.get_tool_schemas","title":"<code>get_tool_schemas()</code>","text":"<p>Get schemas for all tools.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A list of tool schemas</p> Source code in <code>src/openapi/tools.py</code> <pre><code>def get_tool_schemas(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get schemas for all tools.\n\n    Returns:\n        A list of tool schemas\n    \"\"\"\n    return [tool.to_schema() for tool in self.tools]\n</code></pre>"},{"location":"api/openapi/#src.openapi.OpenAPIToolkit.get_tools","title":"<code>get_tools()</code>","text":"<p>Get all tools from the toolkit.</p> <p>Returns:</p> Type Description <code>List[RestApiTool]</code> <p>A list of REST API tools</p> Source code in <code>src/openapi/tools.py</code> <pre><code>def get_tools(self) -&gt; List[RestApiTool]:\n    \"\"\"Get all tools from the toolkit.\n\n    Returns:\n        A list of REST API tools\n    \"\"\"\n    return self.tools\n</code></pre>"},{"location":"api/openapi/#src.openapi.ReducedOpenAPISpec","title":"<code>ReducedOpenAPISpec</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A reduced OpenAPI spec for efficient processing.</p> <p>This is a simplified representation of OpenAPI specs that focuses on the most important parts for tool creation.</p> Source code in <code>src/openapi/spec.py</code> <pre><code>class ReducedOpenAPISpec(BaseModel):\n    \"\"\"A reduced OpenAPI spec for efficient processing.\n\n    This is a simplified representation of OpenAPI specs that focuses\n    on the most important parts for tool creation.\n    \"\"\"\n\n    servers: List[Dict[str, Any]]\n    description: str\n    endpoints: List[Tuple[str, str, Dict[str, Any]]]\n</code></pre>"},{"location":"api/openapi/#src.openapi.RestApiTool","title":"<code>RestApiTool</code>","text":"<p>Tool for making requests to a REST API endpoint.</p> Source code in <code>src/openapi/tools.py</code> <pre><code>class RestApiTool:\n    \"\"\"Tool for making requests to a REST API endpoint.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: str,\n        endpoint: ApiEndpoint,\n        base_url: str,\n        auth_config: Optional[ApiAuthConfig] = None,\n        rate_limit_config: Optional[RateLimitConfig] = None,\n        retry_config: Optional[RetryConfig] = None,\n        pagination_config: Optional[PaginationConfig] = None,\n    ):\n        \"\"\"Initialize a REST API tool.\n\n        Args:\n            name: Name of the tool\n            description: Description of the tool\n            endpoint: API endpoint details\n            base_url: Base URL for the API\n            auth_config: Authentication configuration\n            rate_limit_config: Rate limiting configuration\n            retry_config: Retry configuration\n            pagination_config: Pagination configuration\n        \"\"\"\n        self.name = name\n        self.description = description\n        self.endpoint = endpoint\n        self.base_url = base_url\n        self.auth_config = auth_config\n        self.auth_scheme = None\n        self.auth_credential = None\n\n        # Set up rate limiting and retry handling\n        self.rate_limit_config = rate_limit_config or RateLimitConfig()\n        self.retry_config = retry_config or RetryConfig()\n        self.pagination_config = pagination_config or PaginationConfig()\n        self.rate_limiter = RateLimiter(self.rate_limit_config)\n        self.retry_handler = RetryHandler(self.retry_config)\n        self.pagination_handler = PaginationHandler(self.pagination_config)\n\n        # Setup auth scheme and credential using auth_helpers if auth_config is provided\n        if auth_config:\n            try:\n                if auth_config.type == \"apiKey\":\n                    self.auth_scheme, self.auth_credential = (\n                        auth_helpers.token_to_scheme_credential(\n                            token_type=\"apikey\",\n                            location=auth_config.in_field,\n                            name=auth_config.name,\n                            credential_value=auth_config.value,\n                        )\n                    )\n                elif auth_config.type == \"http\":\n                    # Handle HTTP auth (Basic or Bearer)\n                    if auth_config.scheme == \"basic\":\n                        # Handle basic auth with username and password\n                        if hasattr(auth_config, \"username\") and hasattr(\n                            auth_config, \"password\"\n                        ):\n                            self.auth_scheme, self.auth_credential = (\n                                auth_helpers.token_to_scheme_credential(\n                                    token_type=\"basic\",\n                                    username=auth_config.username,\n                                    password=auth_config.password,\n                                )\n                            )\n                        # Or with pre-formatted credential\n                        elif hasattr(auth_config, \"value\"):\n                            self.auth_scheme, self.auth_credential = (\n                                auth_helpers.token_to_scheme_credential(\n                                    token_type=\"basic\",\n                                    credential_value=auth_config.value,\n                                )\n                            )\n                    elif auth_config.scheme == \"bearer\":\n                        # Handle bearer token auth\n                        self.auth_scheme, self.auth_credential = (\n                            auth_helpers.token_to_scheme_credential(\n                                token_type=\"bearer\",\n                                credential_value=auth_config.value,\n                            )\n                        )\n                elif auth_config.type == \"oauth2\":\n                    # Handle OAuth2 auth\n                    self.auth_scheme, self.auth_credential = (\n                        auth_helpers.token_to_scheme_credential(\n                            token_type=\"oauth2\",\n                            credential_value=auth_config.value,\n                        )\n                    )\n            except ValueError as e:\n                logger.error(f\"Error setting up auth: {e}\")\n\n    def to_schema(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert the tool to a schema for LLM function calling.\n\n        Returns:\n            A schema for the tool\n        \"\"\"\n        # Build parameter schema based on endpoint parameters\n        properties = {}\n        required = []\n\n        for param in self.endpoint.parameters:\n            param_schema = param.schema_definition.copy()\n            properties[param.name] = {\n                \"type\": param_schema.get(\"type\", \"string\"),\n                \"description\": param.description,\n            }\n\n            # Add enum values if available\n            if \"enum\" in param_schema:\n                properties[param.name][\"enum\"] = param_schema[\"enum\"]\n\n            if param.required:\n                required.append(param.name)\n\n        # Add request body parameters if present\n        if self.endpoint.request_body:\n            content = self.endpoint.request_body.get(\"content\", {})\n            for content_type, content_schema in content.items():\n                if \"application/json\" in content_type:\n                    schema = content_schema.get(\"schema\", {})\n                    if \"properties\" in schema:\n                        for prop_name, prop_schema in schema[\"properties\"].items():\n                            properties[prop_name] = prop_schema\n                            if \"required\" in schema and prop_name in schema[\"required\"]:\n                                required.append(prop_name)\n\n        # Build the complete schema\n        schema = {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": properties,\n                \"required\": required,\n            },\n        }\n\n        return schema\n\n    def execute(self, **kwargs: Any) -&gt; Dict[str, Any]:\n        \"\"\"Execute the API request with retry and rate limiting.\n\n        Args:\n            **kwargs: Parameters for the API request\n\n        Returns:\n            The API response\n        \"\"\"\n        # Check rate limits before making the request\n        wait_time = self.rate_limiter.wait_time_seconds()\n        if wait_time &gt; 0:\n            logger.info(\n                f\"Rate limit reached. Waiting {wait_time:.2f} seconds before making request.\"\n            )\n            time.sleep(wait_time)\n\n        # Prepare URL with path parameters\n        url = f\"{self.base_url}{self.endpoint.path}\"\n\n        # Separate parameters by location\n        path_params = {}\n        query_params = {}\n        header_params = {}\n        body_params = {}\n\n        for param in self.endpoint.parameters:\n            if param.name in kwargs:\n                value = kwargs[param.name]\n                if param.location == \"path\":\n                    path_params[param.name] = value\n                elif param.location == \"query\":\n                    query_params[param.name] = value\n                elif param.location == \"header\":\n                    header_params[param.name] = value\n                elif param.location == \"body\":\n                    body_params[param.name] = value\n\n        # Format URL with path parameters\n        for param_name, param_value in path_params.items():\n            url = url.replace(f\"{{{param_name}}}\", str(param_value))\n\n        # Add authentication if configured using auth_helpers\n        if self.auth_scheme and self.auth_credential:\n            try:\n                api_param, auth_kwargs = auth_helpers.credential_to_param(\n                    self.auth_scheme, self.auth_credential\n                )\n                if api_param and auth_kwargs:\n                    # Extract the auth parameter and add it to the appropriate location\n                    for param_name, param_value in auth_kwargs.items():\n                        # Remove the internal prefix from auth_helpers\n                        clean_name = param_name.replace(\n                            auth_helpers.INTERNAL_AUTH_PREFIX, \"\"\n                        )\n                        if api_param.location == \"header\":\n                            header_params[clean_name] = param_value\n                        elif api_param.location == \"query\":\n                            query_params[clean_name] = param_value\n            except ValueError as e:\n                logger.error(f\"Error applying auth: {e}\")\n\n        # If pagination is enabled, prepare for collecting paginated responses\n        paginated_responses = []\n        current_page = 0\n        current_query_params = query_params.copy()\n        current_url = url\n\n        while True:\n            # Implement retry loop with exponential backoff\n            attempt = 0\n            while True:\n                try:\n                    # Consume a rate limit token\n                    self.rate_limiter.consume_token()\n\n                    # Make the request\n                    method = self.endpoint.method.lower()\n                    if method == \"get\":\n                        response = requests.get(\n                            current_url,\n                            params=current_query_params,\n                            headers=header_params,\n                            timeout=30,\n                        )\n                    elif method == \"post\":\n                        response = requests.post(\n                            current_url,\n                            params=current_query_params,\n                            headers=header_params,\n                            json=body_params if body_params else None,\n                            timeout=30,\n                        )\n                    else:\n                        raise ValueError(f\"Unsupported HTTP method: {method}\")\n\n                    # Check status code and raise for retry if needed\n                    if self.retry_handler.should_retry(response.status_code, attempt):\n                        attempt += 1\n                        backoff_time = self.retry_handler.get_backoff_time(attempt)\n                        logger.info(\n                            f\"Request failed with status {response.status_code}. \"\n                            f\"Retrying in {backoff_time:.2f} seconds (attempt {attempt}/{self.retry_config.max_retries})\"\n                        )\n                        time.sleep(backoff_time)\n                        continue\n\n                    # Raise for other error status codes\n                    response.raise_for_status()\n\n                    # Parse response\n                    if response.content:\n                        try:\n                            response_data = response.json()\n                        except ValueError:\n                            response_data = {\"text\": response.text}\n                    else:\n                        response_data = {\n                            \"status\": \"Success\",\n                            \"status_code\": response.status_code,\n                        }\n\n                    # Add response to paginated responses if pagination is enabled\n                    if self.pagination_config.enabled:\n                        paginated_responses.append(response_data)\n\n                        # Get parameters for next page\n                        next_page_params = (\n                            self.pagination_handler.prepare_next_page_params(\n                                original_params=current_query_params,\n                                current_page=current_page,\n                                response_data=response_data,\n                                response_headers=dict(response.headers),\n                            )\n                        )\n\n                        if next_page_params:\n                            current_page += 1\n\n                            # Handle special case where we have a full URL from Link header\n                            if \"_pagination_next_url\" in next_page_params:\n                                current_url = next_page_params[\"_pagination_next_url\"]\n                                current_query_params = (\n                                    {}\n                                )  # Clear query params as they're in the URL\n                            else:\n                                current_query_params = next_page_params\n\n                            # Continue to next page\n                            break\n                        else:\n                            # No more pages, combine results and return\n                            if len(paginated_responses) &gt; 1:\n                                return self.pagination_handler.combine_results(\n                                    paginated_responses\n                                )\n                            else:\n                                return response_data\n                    else:\n                        # Pagination not enabled, return single response\n                        return response_data\n\n                except requests.exceptions.RequestException as e:\n                    if (\n                        attempt &lt; self.retry_config.max_retries\n                        and self.retry_config.enabled\n                    ):\n                        attempt += 1\n                        backoff_time = self.retry_handler.get_backoff_time(attempt)\n                        logger.info(\n                            f\"Request failed with error: {str(e)}. \"\n                            f\"Retrying in {backoff_time:.2f} seconds (attempt {attempt}/{self.retry_config.max_retries})\"\n                        )\n                        time.sleep(backoff_time)\n                    else:\n                        logger.error(\n                            f\"Request failed after {attempt} attempts: {str(e)}\"\n                        )\n                        raise\n\n            # If we got here and are not paginating, break the loop\n            if not self.pagination_config.enabled:\n                break\n\n        # This should only be reached if pagination is enabled but no results were found\n        if paginated_responses:\n            return self.pagination_handler.combine_results(paginated_responses)\n        else:\n            return {\"error\": \"No response data available\"}\n</code></pre>"},{"location":"api/openapi/#src.openapi.RestApiTool.__init__","title":"<code>__init__(name, description, endpoint, base_url, auth_config=None, rate_limit_config=None, retry_config=None, pagination_config=None)</code>","text":"<p>Initialize a REST API tool.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tool</p> required <code>description</code> <code>str</code> <p>Description of the tool</p> required <code>endpoint</code> <code>ApiEndpoint</code> <p>API endpoint details</p> required <code>base_url</code> <code>str</code> <p>Base URL for the API</p> required <code>auth_config</code> <code>Optional[ApiAuthConfig]</code> <p>Authentication configuration</p> <code>None</code> <code>rate_limit_config</code> <code>Optional[RateLimitConfig]</code> <p>Rate limiting configuration</p> <code>None</code> <code>retry_config</code> <code>Optional[RetryConfig]</code> <p>Retry configuration</p> <code>None</code> <code>pagination_config</code> <code>Optional[PaginationConfig]</code> <p>Pagination configuration</p> <code>None</code> Source code in <code>src/openapi/tools.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    description: str,\n    endpoint: ApiEndpoint,\n    base_url: str,\n    auth_config: Optional[ApiAuthConfig] = None,\n    rate_limit_config: Optional[RateLimitConfig] = None,\n    retry_config: Optional[RetryConfig] = None,\n    pagination_config: Optional[PaginationConfig] = None,\n):\n    \"\"\"Initialize a REST API tool.\n\n    Args:\n        name: Name of the tool\n        description: Description of the tool\n        endpoint: API endpoint details\n        base_url: Base URL for the API\n        auth_config: Authentication configuration\n        rate_limit_config: Rate limiting configuration\n        retry_config: Retry configuration\n        pagination_config: Pagination configuration\n    \"\"\"\n    self.name = name\n    self.description = description\n    self.endpoint = endpoint\n    self.base_url = base_url\n    self.auth_config = auth_config\n    self.auth_scheme = None\n    self.auth_credential = None\n\n    # Set up rate limiting and retry handling\n    self.rate_limit_config = rate_limit_config or RateLimitConfig()\n    self.retry_config = retry_config or RetryConfig()\n    self.pagination_config = pagination_config or PaginationConfig()\n    self.rate_limiter = RateLimiter(self.rate_limit_config)\n    self.retry_handler = RetryHandler(self.retry_config)\n    self.pagination_handler = PaginationHandler(self.pagination_config)\n\n    # Setup auth scheme and credential using auth_helpers if auth_config is provided\n    if auth_config:\n        try:\n            if auth_config.type == \"apiKey\":\n                self.auth_scheme, self.auth_credential = (\n                    auth_helpers.token_to_scheme_credential(\n                        token_type=\"apikey\",\n                        location=auth_config.in_field,\n                        name=auth_config.name,\n                        credential_value=auth_config.value,\n                    )\n                )\n            elif auth_config.type == \"http\":\n                # Handle HTTP auth (Basic or Bearer)\n                if auth_config.scheme == \"basic\":\n                    # Handle basic auth with username and password\n                    if hasattr(auth_config, \"username\") and hasattr(\n                        auth_config, \"password\"\n                    ):\n                        self.auth_scheme, self.auth_credential = (\n                            auth_helpers.token_to_scheme_credential(\n                                token_type=\"basic\",\n                                username=auth_config.username,\n                                password=auth_config.password,\n                            )\n                        )\n                    # Or with pre-formatted credential\n                    elif hasattr(auth_config, \"value\"):\n                        self.auth_scheme, self.auth_credential = (\n                            auth_helpers.token_to_scheme_credential(\n                                token_type=\"basic\",\n                                credential_value=auth_config.value,\n                            )\n                        )\n                elif auth_config.scheme == \"bearer\":\n                    # Handle bearer token auth\n                    self.auth_scheme, self.auth_credential = (\n                        auth_helpers.token_to_scheme_credential(\n                            token_type=\"bearer\",\n                            credential_value=auth_config.value,\n                        )\n                    )\n            elif auth_config.type == \"oauth2\":\n                # Handle OAuth2 auth\n                self.auth_scheme, self.auth_credential = (\n                    auth_helpers.token_to_scheme_credential(\n                        token_type=\"oauth2\",\n                        credential_value=auth_config.value,\n                    )\n                )\n        except ValueError as e:\n            logger.error(f\"Error setting up auth: {e}\")\n</code></pre>"},{"location":"api/openapi/#src.openapi.RestApiTool.execute","title":"<code>execute(**kwargs)</code>","text":"<p>Execute the API request with retry and rate limiting.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Parameters for the API request</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The API response</p> Source code in <code>src/openapi/tools.py</code> <pre><code>def execute(self, **kwargs: Any) -&gt; Dict[str, Any]:\n    \"\"\"Execute the API request with retry and rate limiting.\n\n    Args:\n        **kwargs: Parameters for the API request\n\n    Returns:\n        The API response\n    \"\"\"\n    # Check rate limits before making the request\n    wait_time = self.rate_limiter.wait_time_seconds()\n    if wait_time &gt; 0:\n        logger.info(\n            f\"Rate limit reached. Waiting {wait_time:.2f} seconds before making request.\"\n        )\n        time.sleep(wait_time)\n\n    # Prepare URL with path parameters\n    url = f\"{self.base_url}{self.endpoint.path}\"\n\n    # Separate parameters by location\n    path_params = {}\n    query_params = {}\n    header_params = {}\n    body_params = {}\n\n    for param in self.endpoint.parameters:\n        if param.name in kwargs:\n            value = kwargs[param.name]\n            if param.location == \"path\":\n                path_params[param.name] = value\n            elif param.location == \"query\":\n                query_params[param.name] = value\n            elif param.location == \"header\":\n                header_params[param.name] = value\n            elif param.location == \"body\":\n                body_params[param.name] = value\n\n    # Format URL with path parameters\n    for param_name, param_value in path_params.items():\n        url = url.replace(f\"{{{param_name}}}\", str(param_value))\n\n    # Add authentication if configured using auth_helpers\n    if self.auth_scheme and self.auth_credential:\n        try:\n            api_param, auth_kwargs = auth_helpers.credential_to_param(\n                self.auth_scheme, self.auth_credential\n            )\n            if api_param and auth_kwargs:\n                # Extract the auth parameter and add it to the appropriate location\n                for param_name, param_value in auth_kwargs.items():\n                    # Remove the internal prefix from auth_helpers\n                    clean_name = param_name.replace(\n                        auth_helpers.INTERNAL_AUTH_PREFIX, \"\"\n                    )\n                    if api_param.location == \"header\":\n                        header_params[clean_name] = param_value\n                    elif api_param.location == \"query\":\n                        query_params[clean_name] = param_value\n        except ValueError as e:\n            logger.error(f\"Error applying auth: {e}\")\n\n    # If pagination is enabled, prepare for collecting paginated responses\n    paginated_responses = []\n    current_page = 0\n    current_query_params = query_params.copy()\n    current_url = url\n\n    while True:\n        # Implement retry loop with exponential backoff\n        attempt = 0\n        while True:\n            try:\n                # Consume a rate limit token\n                self.rate_limiter.consume_token()\n\n                # Make the request\n                method = self.endpoint.method.lower()\n                if method == \"get\":\n                    response = requests.get(\n                        current_url,\n                        params=current_query_params,\n                        headers=header_params,\n                        timeout=30,\n                    )\n                elif method == \"post\":\n                    response = requests.post(\n                        current_url,\n                        params=current_query_params,\n                        headers=header_params,\n                        json=body_params if body_params else None,\n                        timeout=30,\n                    )\n                else:\n                    raise ValueError(f\"Unsupported HTTP method: {method}\")\n\n                # Check status code and raise for retry if needed\n                if self.retry_handler.should_retry(response.status_code, attempt):\n                    attempt += 1\n                    backoff_time = self.retry_handler.get_backoff_time(attempt)\n                    logger.info(\n                        f\"Request failed with status {response.status_code}. \"\n                        f\"Retrying in {backoff_time:.2f} seconds (attempt {attempt}/{self.retry_config.max_retries})\"\n                    )\n                    time.sleep(backoff_time)\n                    continue\n\n                # Raise for other error status codes\n                response.raise_for_status()\n\n                # Parse response\n                if response.content:\n                    try:\n                        response_data = response.json()\n                    except ValueError:\n                        response_data = {\"text\": response.text}\n                else:\n                    response_data = {\n                        \"status\": \"Success\",\n                        \"status_code\": response.status_code,\n                    }\n\n                # Add response to paginated responses if pagination is enabled\n                if self.pagination_config.enabled:\n                    paginated_responses.append(response_data)\n\n                    # Get parameters for next page\n                    next_page_params = (\n                        self.pagination_handler.prepare_next_page_params(\n                            original_params=current_query_params,\n                            current_page=current_page,\n                            response_data=response_data,\n                            response_headers=dict(response.headers),\n                        )\n                    )\n\n                    if next_page_params:\n                        current_page += 1\n\n                        # Handle special case where we have a full URL from Link header\n                        if \"_pagination_next_url\" in next_page_params:\n                            current_url = next_page_params[\"_pagination_next_url\"]\n                            current_query_params = (\n                                {}\n                            )  # Clear query params as they're in the URL\n                        else:\n                            current_query_params = next_page_params\n\n                        # Continue to next page\n                        break\n                    else:\n                        # No more pages, combine results and return\n                        if len(paginated_responses) &gt; 1:\n                            return self.pagination_handler.combine_results(\n                                paginated_responses\n                            )\n                        else:\n                            return response_data\n                else:\n                    # Pagination not enabled, return single response\n                    return response_data\n\n            except requests.exceptions.RequestException as e:\n                if (\n                    attempt &lt; self.retry_config.max_retries\n                    and self.retry_config.enabled\n                ):\n                    attempt += 1\n                    backoff_time = self.retry_handler.get_backoff_time(attempt)\n                    logger.info(\n                        f\"Request failed with error: {str(e)}. \"\n                        f\"Retrying in {backoff_time:.2f} seconds (attempt {attempt}/{self.retry_config.max_retries})\"\n                    )\n                    time.sleep(backoff_time)\n                else:\n                    logger.error(\n                        f\"Request failed after {attempt} attempts: {str(e)}\"\n                    )\n                    raise\n\n        # If we got here and are not paginating, break the loop\n        if not self.pagination_config.enabled:\n            break\n\n    # This should only be reached if pagination is enabled but no results were found\n    if paginated_responses:\n        return self.pagination_handler.combine_results(paginated_responses)\n    else:\n        return {\"error\": \"No response data available\"}\n</code></pre>"},{"location":"api/openapi/#src.openapi.RestApiTool.to_schema","title":"<code>to_schema()</code>","text":"<p>Convert the tool to a schema for LLM function calling.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A schema for the tool</p> Source code in <code>src/openapi/tools.py</code> <pre><code>def to_schema(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert the tool to a schema for LLM function calling.\n\n    Returns:\n        A schema for the tool\n    \"\"\"\n    # Build parameter schema based on endpoint parameters\n    properties = {}\n    required = []\n\n    for param in self.endpoint.parameters:\n        param_schema = param.schema_definition.copy()\n        properties[param.name] = {\n            \"type\": param_schema.get(\"type\", \"string\"),\n            \"description\": param.description,\n        }\n\n        # Add enum values if available\n        if \"enum\" in param_schema:\n            properties[param.name][\"enum\"] = param_schema[\"enum\"]\n\n        if param.required:\n            required.append(param.name)\n\n    # Add request body parameters if present\n    if self.endpoint.request_body:\n        content = self.endpoint.request_body.get(\"content\", {})\n        for content_type, content_schema in content.items():\n            if \"application/json\" in content_type:\n                schema = content_schema.get(\"schema\", {})\n                if \"properties\" in schema:\n                    for prop_name, prop_schema in schema[\"properties\"].items():\n                        properties[prop_name] = prop_schema\n                        if \"required\" in schema and prop_name in schema[\"required\"]:\n                            required.append(prop_name)\n\n    # Build the complete schema\n    schema = {\n        \"name\": self.name,\n        \"description\": self.description,\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": properties,\n            \"required\": required,\n        },\n    }\n\n    return schema\n</code></pre>"},{"location":"api/overview/","title":"API Reference","text":"<p>This section contains the detailed API reference for AutoMCP's Python modules. The documentation is generated automatically from the source code.</p>"},{"location":"api/overview/#package-structure","title":"Package Structure","text":"<p>AutoMCP is organized into the following modules:</p> <ul> <li>main: Command-line interface and entry points</li> <li>manager: MCP server management and configuration</li> <li>utils: Utility functions and helper classes</li> <li>openapi: OpenAPI specification parsing and API interaction</li> <li>mcp: Model Control Protocol implementation</li> <li>documentation: Documentation crawling and resource management</li> <li>prompt: Prompt management and generation</li> </ul>"},{"location":"api/overview/#using-the-api-reference","title":"Using the API Reference","text":"<p>Each module's documentation includes:</p> <ul> <li>Function and class definitions</li> <li>Parameter descriptions</li> <li>Return value information </li> <li>Code examples (where available)</li> </ul>"},{"location":"api/overview/#core-components","title":"Core Components","text":"<p>The core components of AutoMCP are:</p>"},{"location":"api/overview/#cli","title":"CLI","text":"<p>The command-line interface provides commands for: - Adding API configurations - Listing registered servers - Deleting servers - Starting the MCP server - Installing configurations for LLMs like Claude</p>"},{"location":"api/overview/#openapi-processing","title":"OpenAPI Processing","text":"<p>The OpenAPI module handles: - Parsing OpenAPI specifications - Converting API endpoints to MCP tools - Managing authentication and rate limiting</p>"},{"location":"api/overview/#documentation-management","title":"Documentation Management","text":"<p>The documentation module provides: - Web crawling of API documentation - Document parsing and chunking - Vector database storage and retrieval</p>"},{"location":"api/overview/#mcp-server","title":"MCP Server","text":"<p>The MCP server implements: - Tools API for executing API calls - Resources API for retrieving documentation - Prompts API for managing prompts </p>"},{"location":"api/prompt/","title":"Prompt Module","text":"<p>Prompt handling module for AutoMCP.</p>"},{"location":"api/prompt/#src.prompt.PromptGenerator","title":"<code>PromptGenerator</code>","text":"<p>Generator for API tool prompts.</p> Source code in <code>src/prompt/generator.py</code> <pre><code>class PromptGenerator:\n    \"\"\"Generator for API tool prompts.\"\"\"\n\n    def __init__(\n        self,\n        api_name: str,\n        api_description: str,\n        tools: List[Dict],\n        resources: Dict,\n        custom_prompts: Optional[List[Dict[str, str]]] = None,\n    ):\n        \"\"\"Initialize the prompt generator.\n\n        Args:\n            api_name: Name of the API\n            api_description: Description of the API\n            tools: List of tools as dictionaries\n            resources: Dictionary of resources\n            custom_prompts: Optional list of custom prompts from the config file\n        \"\"\"\n        self.api_name = api_name\n        self.api_description = api_description\n        self.tools = tools\n        self.resources = resources\n        self.custom_prompts = custom_prompts or []\n\n    def create_api_overview_prompt(self) -&gt; PromptTemplate:\n        \"\"\"Create a prompt template for an overview of the API.\n\n        Returns:\n            A prompt template\n        \"\"\"\n        # Get list of all tools\n        tool_names = [tool[\"name\"] for tool in self.tools]\n\n        # Create the template\n        template = f\"\"\"# {self.api_name} Overview\n\n{self.api_description}\n\nThis API provides the following tools:\n{', '.join(tool_names)}\n\nTo use this API, you can call any of the available tools.\n\nExample:\n```\nTo get information about X, you can use the get_x tool.\n```\n\nLet me know what specific information you need from the {self.api_name} API, and I'll help you find the right tool to use.\n\"\"\"\n\n        return PromptTemplate(\n            id=\"api_overview\",\n            name=f\"{self.api_name} API Overview\",\n            description=f\"Overview of the {self.api_name} API and its tools.\",\n            template=template,\n            variables=[],\n        )\n\n    def create_tool_usage_guide_prompt(self) -&gt; PromptTemplate:\n        \"\"\"Create a prompt template for tool usage guide.\n\n        Returns:\n            A prompt template\n        \"\"\"\n        template = f\"\"\"# {self.api_name} Tool Usage Guide\n\n**Tool Overview**\nThe tools available for {self.api_name} are generated from its OpenAPI specification. Each tool represents an API endpoint and follows a consistent structure:\n\n1. **Name**: A descriptive name derived from the endpoint operation ID\n2. **Description**: Explanation of what the tool does, taken from the API documentation\n3. **Parameters**: Required and optional parameters for the tool, with data types and descriptions\n\n**How to Use the Tools**\n1. Identify the appropriate tool for your task based on the description\n2. Provide all required parameters in the correct format\n3. Handle the response according to the expected return type\n\n**Tool List**\n{', '.join([tool[\"name\"] for tool in self.tools])}\n\n**Authentication**\nMost API calls require authentication. Check the authentication guide for how to obtain and use API credentials.\n\n**Error Handling**\nWhen tools return errors, check for:\n- Missing required parameters\n- Invalid parameter formats\n- Authentication issues\n- Rate limit restrictions\n- Server errors (may require retries)\n\nFor detailed information about a specific tool, use its name to get parameter requirements and examples.\n\"\"\"\n\n        return PromptTemplate(\n            id=\"tool_usage_guide\",\n            name=\"Tool Usage Guide\",\n            description=\"Guide to understanding and using the tools generated from OpenAPI specs\",\n            template=template,\n            variables=[],\n        )\n\n    def create_resource_usage_guide_prompt(self) -&gt; PromptTemplate:\n        \"\"\"Create a prompt template for resource usage guide.\n\n        Returns:\n            A prompt template\n        \"\"\"\n        resource_count = len(self.resources) if self.resources else 0\n\n        template = f\"\"\"# {self.api_name} Resource Usage Guide\n\n**Understanding API Resources**\nResources are searchable chunks of documentation from the {self.api_name} API documentation. These resources provide context and examples for using the API effectively.\n\n**How Resources are Created**\n1. API documentation pages are crawled from {self.api_name}'s documentation site\n2. Content is extracted, cleaned, and split into semantic chunks\n3. Chunks are embedded and stored in a vector database for semantic search\n\n**Current Resource Database**\n- Total resources: {resource_count}\n- Source: API documentation crawled from official sites\n- Embedding model: OpenAI text-embedding model\n\n**How to Use Resources**\n1. Search for relevant documentation using natural language queries\n2. Reference specific documentation sections when formulating API requests\n3. Use examples from documentation to understand parameter formats and expected responses\n\n**Searching Resources**\nWhen you need information about the API, you can search the documentation resources using the search_documentation tool. This performs a semantic search and returns the most relevant chunks.\n\nExample search: \"How to authenticate with {self.api_name}?\"\n\"\"\"\n\n        return PromptTemplate(\n            id=\"resource_usage_guide\",\n            name=\"Resource Usage Guide\",\n            description=\"Guide to understanding and using the resources created from crawled API documentation\",\n            template=template,\n            variables=[],\n        )\n\n    def create_custom_prompt(\n        self, prompt_data: Dict[str, str], index: int\n    ) -&gt; PromptTemplate:\n        \"\"\"Create a prompt template from custom prompt data.\n\n        Args:\n            prompt_data: Dictionary containing prompt data\n            index: Index of the prompt for ID generation\n\n        Returns:\n            A prompt template\n        \"\"\"\n        prompt_name = prompt_data.get(\"name\", f\"Custom Prompt {index}\")\n        prompt_id = prompt_name.lower().replace(\" \", \"_\")\n\n        return PromptTemplate(\n            id=prompt_id,\n            name=prompt_name,\n            description=prompt_data.get(\"description\", \"\"),\n            template=prompt_data.get(\"content\", \"\"),\n            variables=[],\n        )\n\n    def to_mcp_prompts(self) -&gt; Dict:\n        \"\"\"Convert prompt templates to MCP prompts format.\n\n        Returns:\n            Dictionary of MCP prompts compatible with FastMCP\n        \"\"\"\n        try:\n            from fastmcp.prompts.base import UserMessage, AssistantMessage\n        except ImportError:\n            # Use our mock classes during testing\n            from tests.fixtures.fastmcp_mock import UserMessage, AssistantMessage\n\n        # Create the standard prompts\n        prompts = [\n            self.create_api_overview_prompt(),\n            self.create_tool_usage_guide_prompt(),\n            self.create_resource_usage_guide_prompt(),\n        ]\n\n        # Add custom prompts from the config file\n        for i, prompt_data in enumerate(self.custom_prompts):\n            prompts.append(self.create_custom_prompt(prompt_data, i))\n\n        # Convert to MCP format compatible with FastMCP\n        mcp_prompts = {}\n        for prompt in prompts:\n            prompt_id = prompt.id\n\n            # For tool usage prompts, format as messages for better LLM interaction\n            if prompt_id == \"tool_usage_guide\":\n                mcp_prompts[prompt_id] = [\n                    UserMessage(\"How should I use the tools in this API?\"),\n                    AssistantMessage(prompt.template),\n                    {\"description\": prompt.description},\n                ]\n            elif prompt_id == \"resource_usage_guide\":\n                mcp_prompts[prompt_id] = [\n                    UserMessage(\"How can I use the documentation resources?\"),\n                    AssistantMessage(prompt.template),\n                    {\"description\": prompt.description},\n                ]\n            else:\n                # For other prompts, use the structure expected by FastMCP\n                mcp_prompts[prompt_id] = {\n                    \"name\": prompt.name,\n                    \"description\": prompt.description,\n                    \"template\": prompt.template,\n                    \"variables\": prompt.variables,\n                }\n\n        return mcp_prompts\n</code></pre>"},{"location":"api/prompt/#src.prompt.PromptGenerator.__init__","title":"<code>__init__(api_name, api_description, tools, resources, custom_prompts=None)</code>","text":"<p>Initialize the prompt generator.</p> <p>Parameters:</p> Name Type Description Default <code>api_name</code> <code>str</code> <p>Name of the API</p> required <code>api_description</code> <code>str</code> <p>Description of the API</p> required <code>tools</code> <code>List[Dict]</code> <p>List of tools as dictionaries</p> required <code>resources</code> <code>Dict</code> <p>Dictionary of resources</p> required <code>custom_prompts</code> <code>Optional[List[Dict[str, str]]]</code> <p>Optional list of custom prompts from the config file</p> <code>None</code> Source code in <code>src/prompt/generator.py</code> <pre><code>def __init__(\n    self,\n    api_name: str,\n    api_description: str,\n    tools: List[Dict],\n    resources: Dict,\n    custom_prompts: Optional[List[Dict[str, str]]] = None,\n):\n    \"\"\"Initialize the prompt generator.\n\n    Args:\n        api_name: Name of the API\n        api_description: Description of the API\n        tools: List of tools as dictionaries\n        resources: Dictionary of resources\n        custom_prompts: Optional list of custom prompts from the config file\n    \"\"\"\n    self.api_name = api_name\n    self.api_description = api_description\n    self.tools = tools\n    self.resources = resources\n    self.custom_prompts = custom_prompts or []\n</code></pre>"},{"location":"api/prompt/#src.prompt.PromptGenerator.create_api_overview_prompt","title":"<code>create_api_overview_prompt()</code>","text":"<p>Create a prompt template for an overview of the API.</p> <p>Returns:</p> Type Description <code>PromptTemplate</code> <p>A prompt template</p> Source code in <code>src/prompt/generator.py</code> <pre><code>    def create_api_overview_prompt(self) -&gt; PromptTemplate:\n        \"\"\"Create a prompt template for an overview of the API.\n\n        Returns:\n            A prompt template\n        \"\"\"\n        # Get list of all tools\n        tool_names = [tool[\"name\"] for tool in self.tools]\n\n        # Create the template\n        template = f\"\"\"# {self.api_name} Overview\n\n{self.api_description}\n\nThis API provides the following tools:\n{', '.join(tool_names)}\n\nTo use this API, you can call any of the available tools.\n\nExample:\n```\nTo get information about X, you can use the get_x tool.\n```\n\nLet me know what specific information you need from the {self.api_name} API, and I'll help you find the right tool to use.\n\"\"\"\n\n        return PromptTemplate(\n            id=\"api_overview\",\n            name=f\"{self.api_name} API Overview\",\n            description=f\"Overview of the {self.api_name} API and its tools.\",\n            template=template,\n            variables=[],\n        )\n</code></pre>"},{"location":"api/prompt/#src.prompt.PromptGenerator.create_custom_prompt","title":"<code>create_custom_prompt(prompt_data, index)</code>","text":"<p>Create a prompt template from custom prompt data.</p> <p>Parameters:</p> Name Type Description Default <code>prompt_data</code> <code>Dict[str, str]</code> <p>Dictionary containing prompt data</p> required <code>index</code> <code>int</code> <p>Index of the prompt for ID generation</p> required <p>Returns:</p> Type Description <code>PromptTemplate</code> <p>A prompt template</p> Source code in <code>src/prompt/generator.py</code> <pre><code>def create_custom_prompt(\n    self, prompt_data: Dict[str, str], index: int\n) -&gt; PromptTemplate:\n    \"\"\"Create a prompt template from custom prompt data.\n\n    Args:\n        prompt_data: Dictionary containing prompt data\n        index: Index of the prompt for ID generation\n\n    Returns:\n        A prompt template\n    \"\"\"\n    prompt_name = prompt_data.get(\"name\", f\"Custom Prompt {index}\")\n    prompt_id = prompt_name.lower().replace(\" \", \"_\")\n\n    return PromptTemplate(\n        id=prompt_id,\n        name=prompt_name,\n        description=prompt_data.get(\"description\", \"\"),\n        template=prompt_data.get(\"content\", \"\"),\n        variables=[],\n    )\n</code></pre>"},{"location":"api/prompt/#src.prompt.PromptGenerator.create_resource_usage_guide_prompt","title":"<code>create_resource_usage_guide_prompt()</code>","text":"<p>Create a prompt template for resource usage guide.</p> <p>Returns:</p> Type Description <code>PromptTemplate</code> <p>A prompt template</p> Source code in <code>src/prompt/generator.py</code> <pre><code>    def create_resource_usage_guide_prompt(self) -&gt; PromptTemplate:\n        \"\"\"Create a prompt template for resource usage guide.\n\n        Returns:\n            A prompt template\n        \"\"\"\n        resource_count = len(self.resources) if self.resources else 0\n\n        template = f\"\"\"# {self.api_name} Resource Usage Guide\n\n**Understanding API Resources**\nResources are searchable chunks of documentation from the {self.api_name} API documentation. These resources provide context and examples for using the API effectively.\n\n**How Resources are Created**\n1. API documentation pages are crawled from {self.api_name}'s documentation site\n2. Content is extracted, cleaned, and split into semantic chunks\n3. Chunks are embedded and stored in a vector database for semantic search\n\n**Current Resource Database**\n- Total resources: {resource_count}\n- Source: API documentation crawled from official sites\n- Embedding model: OpenAI text-embedding model\n\n**How to Use Resources**\n1. Search for relevant documentation using natural language queries\n2. Reference specific documentation sections when formulating API requests\n3. Use examples from documentation to understand parameter formats and expected responses\n\n**Searching Resources**\nWhen you need information about the API, you can search the documentation resources using the search_documentation tool. This performs a semantic search and returns the most relevant chunks.\n\nExample search: \"How to authenticate with {self.api_name}?\"\n\"\"\"\n\n        return PromptTemplate(\n            id=\"resource_usage_guide\",\n            name=\"Resource Usage Guide\",\n            description=\"Guide to understanding and using the resources created from crawled API documentation\",\n            template=template,\n            variables=[],\n        )\n</code></pre>"},{"location":"api/prompt/#src.prompt.PromptGenerator.create_tool_usage_guide_prompt","title":"<code>create_tool_usage_guide_prompt()</code>","text":"<p>Create a prompt template for tool usage guide.</p> <p>Returns:</p> Type Description <code>PromptTemplate</code> <p>A prompt template</p> Source code in <code>src/prompt/generator.py</code> <pre><code>    def create_tool_usage_guide_prompt(self) -&gt; PromptTemplate:\n        \"\"\"Create a prompt template for tool usage guide.\n\n        Returns:\n            A prompt template\n        \"\"\"\n        template = f\"\"\"# {self.api_name} Tool Usage Guide\n\n**Tool Overview**\nThe tools available for {self.api_name} are generated from its OpenAPI specification. Each tool represents an API endpoint and follows a consistent structure:\n\n1. **Name**: A descriptive name derived from the endpoint operation ID\n2. **Description**: Explanation of what the tool does, taken from the API documentation\n3. **Parameters**: Required and optional parameters for the tool, with data types and descriptions\n\n**How to Use the Tools**\n1. Identify the appropriate tool for your task based on the description\n2. Provide all required parameters in the correct format\n3. Handle the response according to the expected return type\n\n**Tool List**\n{', '.join([tool[\"name\"] for tool in self.tools])}\n\n**Authentication**\nMost API calls require authentication. Check the authentication guide for how to obtain and use API credentials.\n\n**Error Handling**\nWhen tools return errors, check for:\n- Missing required parameters\n- Invalid parameter formats\n- Authentication issues\n- Rate limit restrictions\n- Server errors (may require retries)\n\nFor detailed information about a specific tool, use its name to get parameter requirements and examples.\n\"\"\"\n\n        return PromptTemplate(\n            id=\"tool_usage_guide\",\n            name=\"Tool Usage Guide\",\n            description=\"Guide to understanding and using the tools generated from OpenAPI specs\",\n            template=template,\n            variables=[],\n        )\n</code></pre>"},{"location":"api/prompt/#src.prompt.PromptGenerator.to_mcp_prompts","title":"<code>to_mcp_prompts()</code>","text":"<p>Convert prompt templates to MCP prompts format.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary of MCP prompts compatible with FastMCP</p> Source code in <code>src/prompt/generator.py</code> <pre><code>def to_mcp_prompts(self) -&gt; Dict:\n    \"\"\"Convert prompt templates to MCP prompts format.\n\n    Returns:\n        Dictionary of MCP prompts compatible with FastMCP\n    \"\"\"\n    try:\n        from fastmcp.prompts.base import UserMessage, AssistantMessage\n    except ImportError:\n        # Use our mock classes during testing\n        from tests.fixtures.fastmcp_mock import UserMessage, AssistantMessage\n\n    # Create the standard prompts\n    prompts = [\n        self.create_api_overview_prompt(),\n        self.create_tool_usage_guide_prompt(),\n        self.create_resource_usage_guide_prompt(),\n    ]\n\n    # Add custom prompts from the config file\n    for i, prompt_data in enumerate(self.custom_prompts):\n        prompts.append(self.create_custom_prompt(prompt_data, i))\n\n    # Convert to MCP format compatible with FastMCP\n    mcp_prompts = {}\n    for prompt in prompts:\n        prompt_id = prompt.id\n\n        # For tool usage prompts, format as messages for better LLM interaction\n        if prompt_id == \"tool_usage_guide\":\n            mcp_prompts[prompt_id] = [\n                UserMessage(\"How should I use the tools in this API?\"),\n                AssistantMessage(prompt.template),\n                {\"description\": prompt.description},\n            ]\n        elif prompt_id == \"resource_usage_guide\":\n            mcp_prompts[prompt_id] = [\n                UserMessage(\"How can I use the documentation resources?\"),\n                AssistantMessage(prompt.template),\n                {\"description\": prompt.description},\n            ]\n        else:\n            # For other prompts, use the structure expected by FastMCP\n            mcp_prompts[prompt_id] = {\n                \"name\": prompt.name,\n                \"description\": prompt.description,\n                \"template\": prompt.template,\n                \"variables\": prompt.variables,\n            }\n\n    return mcp_prompts\n</code></pre>"},{"location":"api/prompt/#src.prompt.PromptTemplate","title":"<code>PromptTemplate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Template for a prompt to be used with an API.</p> Source code in <code>src/prompt/generator.py</code> <pre><code>class PromptTemplate(BaseModel):\n    \"\"\"Template for a prompt to be used with an API.\"\"\"\n\n    id: str\n    name: str\n    description: str\n    template: str\n    variables: List[str] = []\n</code></pre>"},{"location":"api/prompt/#src.prompt.format_template","title":"<code>format_template(template, **kwargs)</code>","text":"<p>Format a template string with the provided variables.</p> <p>This function provides a safe way to format prompt templates.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>str</code> <p>The template string to format.</p> required <code>**kwargs</code> <code>Any</code> <p>The variables to use for formatting.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The formatted template string.</p> Source code in <code>src/prompt/__init__.py</code> <pre><code>def format_template(template: str, **kwargs: Any) -&gt; str:\n    \"\"\"Format a template string with the provided variables.\n\n    This function provides a safe way to format prompt templates.\n\n    Args:\n        template: The template string to format.\n        **kwargs: The variables to use for formatting.\n\n    Returns:\n        The formatted template string.\n    \"\"\"\n    return template.format(**kwargs)\n</code></pre>"},{"location":"api/utils/","title":"Utils Module","text":"<p>Name: Utility functions. Description: Common utility functions for AutoMCP, including loading OpenAPI specs, managing server registries, and logging.</p>"},{"location":"api/utils/#src.utils.ApiConfig","title":"<code>ApiConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for an API.</p> Source code in <code>src/utils.py</code> <pre><code>class ApiConfig(BaseModel):\n    \"\"\"Configuration for an API.\"\"\"\n\n    name: str\n    display_name: Optional[str] = None\n    description: str\n    icon: Optional[str] = None\n    version: Optional[str] = None\n    documentation_url: Optional[str] = None\n    openapi_spec_url: str\n    openapi_spec: Optional[Dict[str, Any]] = None\n    authentication: Optional[Dict[str, Any]] = None\n    rate_limits: Optional[Dict[str, Any]] = None\n    retry: Optional[Dict[str, Any]] = None\n    crawl: Optional[Dict[str, Any]] = None\n    prompts: Optional[List[Dict[str, str]]] = None\n\n    @property\n    def server_name(self) -&gt; str:\n        \"\"\"Get the standardized server name (lowercase with underscores).\n\n        Returns:\n            Standardized server name for use in URLs and file paths\n        \"\"\"\n        return self.name.lower().replace(\" \", \"_\") if self.name else \"\"\n</code></pre>"},{"location":"api/utils/#src.utils.ApiConfig.server_name","title":"<code>server_name: str</code>  <code>property</code>","text":"<p>Get the standardized server name (lowercase with underscores).</p> <p>Returns:</p> Type Description <code>str</code> <p>Standardized server name for use in URLs and file paths</p>"},{"location":"api/utils/#src.utils.ServerRegistry","title":"<code>ServerRegistry</code>","text":"<p>Registry for managing API servers.</p> Source code in <code>src/utils.py</code> <pre><code>class ServerRegistry:\n    \"\"\"Registry for managing API servers.\"\"\"\n\n    def __init__(self, registry_path: str = DEFAULT_REGISTRY_FILE):\n        \"\"\"Initialize the server registry.\n\n        Args:\n            registry_path: Path to the registry file\n        \"\"\"\n        self.registry_path = registry_path\n        self._ensure_registry_file()\n\n    def _ensure_registry_file(self):\n        \"\"\"Ensure the registry file exists.\"\"\"\n        registry_dir = os.path.dirname(self.registry_path)\n        if not os.path.exists(registry_dir):\n            os.makedirs(registry_dir, exist_ok=True)\n\n        if not os.path.exists(self.registry_path):\n            # Create empty registry\n            self._save_registry({})\n\n    def _load_registry(self) -&gt; Dict[str, Dict[str, Any]]:\n        \"\"\"Load the registry from file.\n\n        Returns:\n            Dictionary of server configurations\n        \"\"\"\n        try:\n            with open(self.registry_path, \"r\") as f:\n                return json.load(f)\n        except (json.JSONDecodeError, FileNotFoundError):\n            return {}\n\n    def _save_registry(self, registry: Dict[str, Dict[str, Any]]):\n        \"\"\"Save the registry to file.\n\n        Args:\n            registry: Dictionary of server configurations\n        \"\"\"\n        with open(self.registry_path, \"w\") as f:\n            json.dump(registry, f, indent=2)\n\n    def add_server(self, name: str, config_path: str, db_directory: str):\n        \"\"\"Add or update a server in the registry.\n\n        Args:\n            name: Server name\n            config_path: Path to the server config file\n            db_directory: Path to the database directory\n        \"\"\"\n        registry = self._load_registry()\n        registry[name] = {\n            \"name\": name,\n            \"config_path\": config_path,\n            \"db_directory\": db_directory,\n            \"added_at\": str(datetime.datetime.now()),\n        }\n        self._save_registry(registry)\n\n    def list_servers(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all registered servers.\n\n        Returns:\n            List of server configurations\n        \"\"\"\n        registry = self._load_registry()\n        return list(registry.values())\n\n    def get_server(self, name: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get a server configuration by name.\n\n        Args:\n            name: Server name\n\n        Returns:\n            Server configuration, or None if not found\n        \"\"\"\n        registry = self._load_registry()\n        return registry.get(name)\n\n    def delete_server(self, name: str) -&gt; bool:\n        \"\"\"Delete a server from the registry.\n\n        Args:\n            name: Server name\n\n        Returns:\n            True if the server was deleted, False if not found\n        \"\"\"\n        registry = self._load_registry()\n        if name in registry:\n            del registry[name]\n            self._save_registry(registry)\n            return True\n        return False\n\n    def get_all_config_paths(self) -&gt; List[str]:\n        \"\"\"Get all registered config file paths.\n\n        Returns:\n            List of config file paths\n        \"\"\"\n        registry = self._load_registry()\n        return [server[\"config_path\"] for server in registry.values()]\n\n    def get_db_directory(self, name: str) -&gt; Optional[str]:\n        \"\"\"Get the database directory for a server by name.\n\n        Args:\n            name: Server name\n\n        Returns:\n            Database directory path, or None if not found\n        \"\"\"\n        server = self.get_server(name)\n        if server:\n            return server.get(\"db_directory\")\n        return None\n</code></pre>"},{"location":"api/utils/#src.utils.ServerRegistry.__init__","title":"<code>__init__(registry_path=DEFAULT_REGISTRY_FILE)</code>","text":"<p>Initialize the server registry.</p> <p>Parameters:</p> Name Type Description Default <code>registry_path</code> <code>str</code> <p>Path to the registry file</p> <code>DEFAULT_REGISTRY_FILE</code> Source code in <code>src/utils.py</code> <pre><code>def __init__(self, registry_path: str = DEFAULT_REGISTRY_FILE):\n    \"\"\"Initialize the server registry.\n\n    Args:\n        registry_path: Path to the registry file\n    \"\"\"\n    self.registry_path = registry_path\n    self._ensure_registry_file()\n</code></pre>"},{"location":"api/utils/#src.utils.ServerRegistry.add_server","title":"<code>add_server(name, config_path, db_directory)</code>","text":"<p>Add or update a server in the registry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Server name</p> required <code>config_path</code> <code>str</code> <p>Path to the server config file</p> required <code>db_directory</code> <code>str</code> <p>Path to the database directory</p> required Source code in <code>src/utils.py</code> <pre><code>def add_server(self, name: str, config_path: str, db_directory: str):\n    \"\"\"Add or update a server in the registry.\n\n    Args:\n        name: Server name\n        config_path: Path to the server config file\n        db_directory: Path to the database directory\n    \"\"\"\n    registry = self._load_registry()\n    registry[name] = {\n        \"name\": name,\n        \"config_path\": config_path,\n        \"db_directory\": db_directory,\n        \"added_at\": str(datetime.datetime.now()),\n    }\n    self._save_registry(registry)\n</code></pre>"},{"location":"api/utils/#src.utils.ServerRegistry.delete_server","title":"<code>delete_server(name)</code>","text":"<p>Delete a server from the registry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Server name</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the server was deleted, False if not found</p> Source code in <code>src/utils.py</code> <pre><code>def delete_server(self, name: str) -&gt; bool:\n    \"\"\"Delete a server from the registry.\n\n    Args:\n        name: Server name\n\n    Returns:\n        True if the server was deleted, False if not found\n    \"\"\"\n    registry = self._load_registry()\n    if name in registry:\n        del registry[name]\n        self._save_registry(registry)\n        return True\n    return False\n</code></pre>"},{"location":"api/utils/#src.utils.ServerRegistry.get_all_config_paths","title":"<code>get_all_config_paths()</code>","text":"<p>Get all registered config file paths.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of config file paths</p> Source code in <code>src/utils.py</code> <pre><code>def get_all_config_paths(self) -&gt; List[str]:\n    \"\"\"Get all registered config file paths.\n\n    Returns:\n        List of config file paths\n    \"\"\"\n    registry = self._load_registry()\n    return [server[\"config_path\"] for server in registry.values()]\n</code></pre>"},{"location":"api/utils/#src.utils.ServerRegistry.get_db_directory","title":"<code>get_db_directory(name)</code>","text":"<p>Get the database directory for a server by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Server name</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Database directory path, or None if not found</p> Source code in <code>src/utils.py</code> <pre><code>def get_db_directory(self, name: str) -&gt; Optional[str]:\n    \"\"\"Get the database directory for a server by name.\n\n    Args:\n        name: Server name\n\n    Returns:\n        Database directory path, or None if not found\n    \"\"\"\n    server = self.get_server(name)\n    if server:\n        return server.get(\"db_directory\")\n    return None\n</code></pre>"},{"location":"api/utils/#src.utils.ServerRegistry.get_server","title":"<code>get_server(name)</code>","text":"<p>Get a server configuration by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Server name</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Server configuration, or None if not found</p> Source code in <code>src/utils.py</code> <pre><code>def get_server(self, name: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Get a server configuration by name.\n\n    Args:\n        name: Server name\n\n    Returns:\n        Server configuration, or None if not found\n    \"\"\"\n    registry = self._load_registry()\n    return registry.get(name)\n</code></pre>"},{"location":"api/utils/#src.utils.ServerRegistry.list_servers","title":"<code>list_servers()</code>","text":"<p>List all registered servers.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of server configurations</p> Source code in <code>src/utils.py</code> <pre><code>def list_servers(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all registered servers.\n\n    Returns:\n        List of server configurations\n    \"\"\"\n    registry = self._load_registry()\n    return list(registry.values())\n</code></pre>"},{"location":"api/utils/#src.utils.configure_logging","title":"<code>configure_logging(debug=False)</code>","text":"<p>Configure logging for the application.</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>Whether to enable debug mode</p> <code>False</code> Source code in <code>src/utils.py</code> <pre><code>def configure_logging(debug: bool = False):\n    \"\"\"Configure logging for the application.\n\n    Args:\n        debug: Whether to enable debug mode\n    \"\"\"\n    logging_level = logging.DEBUG if debug else logging.INFO\n    root_logger = logging.getLogger()\n    root_logger.setLevel(logging_level)\n\n    # Check if handlers are already configured to prevent duplicates\n    if root_logger.handlers:\n        # Update existing handlers with the current log level\n        for handler in root_logger.handlers:\n            if isinstance(handler, logging.StreamHandler):\n                handler.setLevel(logging_level)\n        return\n\n    # Create console handler\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setLevel(logging_level)\n\n    # Create formatter\n    formatter = logging.Formatter(\n        \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    )\n    console_handler.setFormatter(formatter)\n\n    # Add handler to the logger\n    root_logger.addHandler(console_handler)\n</code></pre>"},{"location":"api/utils/#src.utils.load_spec_from_file","title":"<code>load_spec_from_file(file_path)</code>","text":"<p>Load OpenAPI spec from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the OpenAPI spec file</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict containing the OpenAPI spec</p> Source code in <code>src/utils.py</code> <pre><code>def load_spec_from_file(file_path: str) -&gt; Dict[str, Any]:\n    \"\"\"Load OpenAPI spec from a file.\n\n    Args:\n        file_path: Path to the OpenAPI spec file\n\n    Returns:\n        Dict containing the OpenAPI spec\n    \"\"\"\n    _, ext = os.path.splitext(file_path)\n    with open(file_path, \"r\") as f:\n        if ext.lower() in (\".yaml\", \".yml\"):\n            return yaml.safe_load(f)\n        elif ext.lower() == \".json\":\n            return json.load(f)\n        else:\n            raise ValueError(f\"Unsupported file extension: {ext}\")\n</code></pre>"},{"location":"api/utils/#src.utils.load_spec_from_url","title":"<code>load_spec_from_url(url)</code>","text":"<p>Load OpenAPI spec from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the OpenAPI spec</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict containing the OpenAPI spec</p> Source code in <code>src/utils.py</code> <pre><code>def load_spec_from_url(url: str) -&gt; Dict[str, Any]:\n    \"\"\"Load OpenAPI spec from a URL.\n\n    Args:\n        url: URL to the OpenAPI spec\n\n    Returns:\n        Dict containing the OpenAPI spec\n    \"\"\"\n    response = requests.get(url, timeout=30)\n    response.raise_for_status()\n    content_type = response.headers.get(\"Content-Type\", \"\")\n\n    if \"application/json\" in content_type:\n        return response.json()\n    elif \"yaml\" in content_type or url.endswith((\".yaml\", \".yml\")):\n        return yaml.safe_load(response.text)\n    else:\n        # Try to parse as JSON first, then fall back to YAML\n        try:\n            return response.json()\n        except json.JSONDecodeError:\n            try:\n                return yaml.safe_load(response.text)\n            except yaml.YAMLError:\n                raise ValueError(\"Unable to parse response as JSON or YAML\")\n</code></pre>"},{"location":"api/utils/#src.utils.setup_environment","title":"<code>setup_environment()</code>","text":"<p>Setup the environment for the application.</p> <ul> <li>Loads environment variables from .env file</li> <li>Downloads required NLTK resources</li> <li>Configures logging</li> </ul> Source code in <code>src/utils.py</code> <pre><code>def setup_environment():\n    \"\"\"Setup the environment for the application.\n\n    - Loads environment variables from .env file\n    - Downloads required NLTK resources\n    - Configures logging\n    \"\"\"\n    import nltk\n\n    # Configure logging first\n    configure_logging()\n\n    try:\n        from dotenv import load_dotenv\n\n        load_dotenv()\n        logger.debug(\"Loaded environment variables from .env file\")\n    except ImportError:\n        logger.warning(\n            \"python-dotenv not installed. Environment variables will only be loaded from system.\"\n        )\n\n    nltk.download(\"punkt\", quiet=True)\n    nltk.download(\"stopwords\", quiet=True)\n</code></pre>"},{"location":"components/documentation_crawler/","title":"Documentation Crawler","text":"<p>The Documentation Crawler is a key component of AutoMCP that indexes API documentation for LLM context.</p>"},{"location":"components/documentation_crawler/#overview","title":"Overview","text":"<p>The Documentation Crawler:</p> <ol> <li>Crawls API documentation websites</li> <li>Extracts content from pages</li> <li>Segments content into manageable chunks</li> <li>Stores chunks in a vector database</li> <li>Provides search capabilities for LLMs</li> </ol>"},{"location":"components/documentation_crawler/#how-it-works","title":"How It Works","text":""},{"location":"components/documentation_crawler/#crawling-process","title":"Crawling Process","text":"<ol> <li>Starting Point: The crawler begins at the URL specified in <code>documentation_url</code></li> <li>Discovery: It finds links to other pages by analyzing HTML</li> <li>Depth Control: It follows links up to the maximum depth</li> <li>Page Limit: It stops after processing the maximum number of pages</li> <li>Content Extraction: It extracts textual content from each page</li> <li>Chunking: It breaks content into smaller, semantic chunks</li> <li>Indexing: It creates embeddings for each chunk and stores them in a vector database</li> </ol>"},{"location":"components/documentation_crawler/#configuration-options","title":"Configuration Options","text":"<pre><code>{\n  \"documentation_url\": \"https://example.com/docs\",\n  \"crawl\": {\n    \"max_depth\": 3,\n    \"max_pages\": 100,\n    \"wait_time\": 1.0,\n    \"chunk_size\": 1000,\n    \"chunk_overlap\": 200\n  }\n}\n</code></pre> Option Type Description Default <code>max_depth</code> number Maximum link depth to crawl <code>3</code> <code>max_pages</code> number Maximum number of pages to process <code>100</code> <code>wait_time</code> number Wait time between requests (seconds) <code>1.0</code> <code>chunk_size</code> number Maximum characters per chunk <code>1000</code> <code>chunk_overlap</code> number Overlap between chunks (characters) <code>200</code>"},{"location":"components/documentation_crawler/#vector-database","title":"Vector Database","text":"<p>AutoMCP uses ChromaDB for vector storage:</p> <ol> <li>Embeddings: Each chunk is converted to vector embeddings</li> <li>Metadata: URLs and titles are stored with each chunk</li> <li>Semantic Search: The database enables similarity-based search</li> <li>Persistent Storage: Embeddings are stored in the specified database directory</li> </ol>"},{"location":"components/documentation_crawler/#resources-api","title":"Resources API","text":"<p>The indexed documentation is exposed through the MCP Resources API, enabling LLMs to:</p> <ol> <li>List Resources: Get a list of all available documentation resources</li> <li>Get Resource Content: Retrieve specific documentation pages</li> <li>Search: Find relevant documentation for queries</li> </ol>"},{"location":"components/documentation_crawler/#example-search","title":"Example Search","text":"<p>When an LLM needs information about authentication, it can search for it:</p> <pre><code>POST /resources/search\nContent-Type: application/json\n\n{\n  \"query\": \"How do I authenticate with the API?\",\n  \"limit\": 3\n}\n</code></pre> <p>The response includes the most relevant documentation chunks:</p> <pre><code>{\n  \"results\": [\n    {\n      \"uri\": \"authentication\",\n      \"title\": \"Authentication Guide\",\n      \"content\": \"# Authentication Guide\\n\\nTo authenticate with our API, you need to provide an API key...\",\n      \"score\": 0.95\n    },\n    // More results...\n  ]\n}\n</code></pre>"},{"location":"components/documentation_crawler/#best-practices","title":"Best Practices","text":"<ol> <li>Set Reasonable Limits: Use appropriate <code>max_depth</code> and <code>max_pages</code> values</li> <li>Respect Rate Limits: Adjust <code>wait_time</code> to avoid overloading the documentation server</li> <li>Tune Chunking: Adjust <code>chunk_size</code> and <code>chunk_overlap</code> for better search quality </li> </ol>"},{"location":"components/mcp_generator/","title":"MCP Generator","text":"<p>The MCP Generator is the component of AutoMCP that transforms OpenAPI specifications into MCP-compatible servers.</p>"},{"location":"components/mcp_generator/#overview","title":"Overview","text":"<p>The MCP Generator:</p> <ol> <li>Parses OpenAPI specifications</li> <li>Converts API operations to MCP tools</li> <li>Creates MCP server endpoints</li> <li>Configures authentication, rate limiting, and other features</li> <li>Manages multiple API servers under a single MCP server</li> </ol>"},{"location":"components/mcp_generator/#generation-process","title":"Generation Process","text":""},{"location":"components/mcp_generator/#from-openapi-to-mcp","title":"From OpenAPI to MCP","text":"<ol> <li>Parse Specification: Extract endpoints, parameters, and descriptions</li> <li>Create Tool Schemas: Convert operations to JSON Schema for parameters</li> <li>Generate Execution Logic: Create the execution functions for each tool</li> <li>Setup MCP Endpoints: Configure the FastAPI routes for the MCP server</li> </ol>"},{"location":"components/mcp_generator/#example-transformation","title":"Example Transformation","text":"<p>OpenAPI Operation: <pre><code>paths:\n  /users/{user_id}:\n    get:\n      operationId: getUser\n      summary: Get user details\n      description: Retrieves detailed information about a user\n      parameters:\n        - name: user_id\n          in: path\n          required: true\n          schema:\n            type: string\n</code></pre></p> <p>MCP Tool: <pre><code>{\n  \"name\": \"getUser\",\n  \"description\": \"Get user details - Retrieves detailed information about a user\",\n  \"parameters\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"user_id\": {\n        \"type\": \"string\",\n        \"description\": \"The ID of the user\"\n      }\n    },\n    \"required\": [\"user_id\"]\n  }\n}\n</code></pre></p>"},{"location":"components/mcp_generator/#mcp-server-structure","title":"MCP Server Structure","text":"<p>The generated MCP server includes:</p>"},{"location":"components/mcp_generator/#1-tools-endpoint","title":"1. Tools Endpoint","text":"<ul> <li><code>GET /api_name/tools</code>: Lists all available tools</li> <li><code>POST /api_name/tools/call</code>: Executes a tool with parameters</li> </ul>"},{"location":"components/mcp_generator/#2-resources-endpoint","title":"2. Resources Endpoint","text":"<ul> <li><code>GET /api_name/resources</code>: Lists all indexed documentation resources</li> <li><code>POST /api_name/resources/call</code>: Retrieves a specific resource</li> <li><code>POST /api_name/resources/search</code>: Searches for resources</li> </ul>"},{"location":"components/mcp_generator/#3-prompts-endpoint","title":"3. Prompts Endpoint","text":"<ul> <li><code>GET /api_name/prompts</code>: Lists all available prompts</li> <li><code>POST /api_name/prompts/call</code>: Retrieves a specific prompt</li> </ul>"},{"location":"components/mcp_generator/#multiple-api-support","title":"Multiple API Support","text":"<p>The MCP Generator can handle multiple APIs in a single server:</p> <ol> <li>Each API gets its own namespace (e.g., <code>/github/tools</code>, <code>/twitter/tools</code>)</li> <li>Tools, resources, and prompts are isolated between APIs</li> <li>Each API can have its own configuration options</li> <li>All APIs are served from a single FastAPI instance</li> </ol>"},{"location":"components/mcp_generator/#configuration-options","title":"Configuration Options","text":"<p>The MCP Generator can be configured through:</p> <pre><code>{\n  \"mcp\": {\n    \"server\": {\n      \"prefix\": \"/api_name\",\n      \"tools_endpoint\": \"/tools\",\n      \"resources_endpoint\": \"/resources\",\n      \"prompts_endpoint\": \"/prompts\"\n    },\n    \"tools\": {\n      \"exclude_operations\": [\"internal_operation\", \"admin_*\"],\n      \"include_operations\": [\"public_*\"]\n    }\n  }\n}\n</code></pre>"},{"location":"components/mcp_generator/#integration-with-claude","title":"Integration with Claude","text":"<p>The MCP Generator can create Claude-compatible configurations:</p> <pre><code>{\n  \"tools\": [\n    {\n      \"name\": \"github\",\n      \"url\": \"http://localhost:8000/github/mcp\",\n      \"schema_version\": \"v1\"\n    }\n  ]\n}\n</code></pre> <p>This can be generated using:</p> <pre><code>automcp install claude --output .claude.json\n</code></pre>"},{"location":"components/mcp_generator/#best-practices","title":"Best Practices","text":"<ol> <li>Use Descriptive Operation IDs: Clear operationIds make better tool names</li> <li>Provide Good Descriptions: Detailed descriptions help LLMs understand tool purposes</li> <li>Filter Operations: Use include/exclude patterns to expose only relevant endpoints</li> <li>Test Integration: Verify the MCP server works correctly with your LLM </li> </ol>"},{"location":"components/openapi/","title":"OpenAPI Integration","text":"<p>AutoMCP uses OpenAPI specifications to automatically generate MCP-compatible tools for your APIs.</p>"},{"location":"components/openapi/#openapi-specifications","title":"OpenAPI Specifications","text":"<p>OpenAPI (formerly known as Swagger) is the industry standard for describing RESTful APIs. AutoMCP works with OpenAPI 3.0 and 3.1 specifications in JSON or YAML format.</p> <p>OpenAPI specifications define:</p> <ul> <li>Available endpoints and operations</li> <li>Operation parameters</li> <li>Input and output schemas</li> <li>Authentication methods</li> <li>API metadata</li> </ul>"},{"location":"components/openapi/#how-automcp-uses-openapi","title":"How AutoMCP Uses OpenAPI","text":"<p>AutoMCP parses OpenAPI specifications to:</p> <ol> <li>Discover Endpoints: Find all available API endpoints and operations</li> <li>Generate Tools: Convert API operations to MCP-compatible tools</li> <li>Extract Metadata: Use descriptions, summaries, and schemas for better context</li> <li>Detect Authentication: Identify authentication requirements</li> </ol>"},{"location":"components/openapi/#example-openapi-specification","title":"Example OpenAPI Specification","text":"<p>Here's a simplified example of an OpenAPI specification:</p> <pre><code>openapi: 3.0.0\ninfo:\n  title: Example API\n  version: 1.0.0\n  description: An example API for demonstration\npaths:\n  /users/{userId}:\n    get:\n      operationId: getUser\n      summary: Get a user by ID\n      description: Retrieves detailed information about a user\n      parameters:\n        - name: userId\n          in: path\n          required: true\n          schema:\n            type: string\n      responses:\n        '200':\n          description: OK\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/User'\ncomponents:\n  schemas:\n    User:\n      type: object\n      properties:\n        id:\n          type: string\n        name:\n          type: string\n        email:\n          type: string\n</code></pre>"},{"location":"components/openapi/#from-openapi-to-mcp-tools","title":"From OpenAPI to MCP Tools","text":"<p>AutoMCP converts each operation in the OpenAPI specification to an MCP tool:</p> <pre><code>{\n  \"name\": \"getUser\",\n  \"description\": \"Get a user by ID - Retrieves detailed information about a user\",\n  \"parameters\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"userId\": {\n        \"type\": \"string\",\n        \"description\": \"The ID of the user\"\n      }\n    },\n    \"required\": [\"userId\"]\n  }\n}\n</code></pre>"},{"location":"components/openapi/#providing-openapi-specifications","title":"Providing OpenAPI Specifications","text":"<p>You can provide OpenAPI specifications in several ways:</p> <ol> <li> <p>URL: Point to a publicly accessible OpenAPI specification    <pre><code>\"openapi_spec_url\": \"https://example.com/openapi.json\"\n</code></pre></p> </li> <li> <p>Local File: Reference a local file    <pre><code>\"openapi_spec_url\": \"./specs/my_api.json\"\n</code></pre></p> </li> <li> <p>Embedded: Include the specification directly in your configuration    <pre><code>\"openapi_spec\": {\n  \"openapi\": \"3.0.0\",\n  \"info\": { ... },\n  \"paths\": { ... }\n}\n</code></pre></p> </li> </ol>"},{"location":"components/openapi/#best-practices","title":"Best Practices","text":"<p>For optimal results with AutoMCP:</p> <ol> <li>Use descriptive <code>operationId</code> values for each operation</li> <li>Provide detailed <code>summary</code> and <code>description</code> fields</li> <li>Include comprehensive parameter descriptions</li> <li>Use schema references (<code>$ref</code>) for consistent types</li> <li>Document authentication requirements clearly</li> </ol> <p>AutoMCP works best with well-documented OpenAPI specifications that follow these practices. </p>"},{"location":"components/prompt_generator/","title":"Prompt Generator","text":"<p>The Prompt Generator component in AutoMCP allows you to define and serve prompts that help LLMs effectively use your API.</p>"},{"location":"components/prompt_generator/#overview","title":"Overview","text":"<p>The Prompt Generator:</p> <ol> <li>Manages prompts defined in API configurations</li> <li>Makes prompts accessible through the MCP server</li> <li>Provides context and guidance for LLMs interacting with your API</li> <li>Enables standardized responses for common tasks</li> </ol>"},{"location":"components/prompt_generator/#prompt-configuration","title":"Prompt Configuration","text":"<p>Prompts are defined in your API configuration file:</p> <pre><code>{\n  \"prompts\": {\n    \"introduction\": {\n      \"description\": \"Introduction to the API\",\n      \"content\": \"This API provides access to user data and analytics...\"\n    },\n    \"authentication\": {\n      \"description\": \"How to authenticate with the API\",\n      \"content\": \"To authenticate, you need to provide an API key in the Authorization header...\"\n    },\n    \"common_use_cases\": {\n      \"description\": \"Common use cases for the API\",\n      \"content\": \"Here are some common tasks you can perform with this API...\"\n    }\n  }\n}\n</code></pre>"},{"location":"components/prompt_generator/#prompt-types","title":"Prompt Types","text":"<p>AutoMCP supports several types of prompts:</p>"},{"location":"components/prompt_generator/#instructional-prompts","title":"Instructional Prompts","text":"<p>These explain how to use the API:</p> <pre><code>{\n  \"prompts\": {\n    \"api_usage\": {\n      \"description\": \"How to use the API effectively\",\n      \"content\": \"When using this API, consider these best practices...\"\n    }\n  }\n}\n</code></pre>"},{"location":"components/prompt_generator/#example-prompts","title":"Example Prompts","text":"<p>These provide examples of API usage:</p> <pre><code>{\n  \"prompts\": {\n    \"search_example\": {\n      \"description\": \"Example of searching for users\",\n      \"content\": \"To search for users, call the searchUsers tool with parameters: { \\\"query\\\": \\\"john\\\", \\\"limit\\\": 10 }\"\n    }\n  }\n}\n</code></pre>"},{"location":"components/prompt_generator/#error-handling-prompts","title":"Error Handling Prompts","text":"<p>These guide error responses:</p> <pre><code>{\n  \"prompts\": {\n    \"rate_limit_handling\": {\n      \"description\": \"How to handle rate limiting errors\",\n      \"content\": \"If you encounter a 429 error, wait for the specified time and try again...\"\n    }\n  }\n}\n</code></pre>"},{"location":"components/prompt_generator/#mcp-prompts-endpoint","title":"MCP Prompts Endpoint","text":"<p>Prompts are accessible through the MCP Prompts endpoint:</p>"},{"location":"components/prompt_generator/#list-prompts","title":"List Prompts","text":"<pre><code>GET /api_name/prompts\n</code></pre> <p>Returns: <pre><code>{\n  \"prompts\": [\n    {\n      \"id\": \"introduction\",\n      \"description\": \"Introduction to the API\"\n    },\n    {\n      \"id\": \"authentication\",\n      \"description\": \"How to authenticate with the API\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"components/prompt_generator/#call-prompt","title":"Call Prompt","text":"<pre><code>POST /api_name/prompts/call\nContent-Type: application/json\n\n{\n  \"id\": \"introduction\"\n}\n</code></pre> <p>Returns: <pre><code>{\n  \"content\": \"This API provides access to user data and analytics...\",\n  \"metadata\": {\n    \"description\": \"Introduction to the API\"\n  }\n}\n</code></pre></p>"},{"location":"components/prompt_generator/#usage-in-llms","title":"Usage in LLMs","text":"<p>LLMs can use prompts to:</p> <ol> <li>Understand APIs: Get an overview of what the API does</li> <li>Learn Authentication: Understand how to authenticate requests</li> <li>Follow Best Practices: Learn recommended usage patterns</li> <li>Handle Errors: Properly respond to error conditions</li> <li>Generate Consistent Responses: Maintain consistent format when presenting API results</li> </ol>"},{"location":"components/prompt_generator/#best-practices","title":"Best Practices","text":"<ol> <li>Keep Prompts Focused: Each prompt should address a specific topic</li> <li>Include Common Scenarios: Cover the most frequent use cases</li> <li>Update Regularly: Keep prompts in sync with API changes</li> <li>Use Markdown: Format content with markdown for better readability</li> <li>Be Concise: Keep prompts clear and to the point </li> </ol>"},{"location":"configuration/authentication/","title":"Authentication","text":"<p>AutoMCP supports various authentication methods for API integrations. This page explains how to configure authentication for your APIs.</p>"},{"location":"configuration/authentication/#supported-authentication-methods","title":"Supported Authentication Methods","text":"<p>AutoMCP currently supports the following authentication methods:</p> <ul> <li>API Key: Authentication using an API key in a header or query parameter</li> <li>Basic Auth: Username and password authentication</li> <li>Bearer Token: Authentication using a Bearer token</li> <li>Environment Variables: Dynamic authentication values from environment variables</li> </ul>"},{"location":"configuration/authentication/#api-key-authentication","title":"API Key Authentication","text":"<p>API key authentication is the most common method and can be configured in the header or query string:</p> <pre><code>{\n  \"authentication\": {\n    \"type\": \"apiKey\",\n    \"in\": \"header\",\n    \"name\": \"X-API-Key\",\n    \"value\": \"your-api-key-here\"\n  }\n}\n</code></pre>"},{"location":"configuration/authentication/#header-based-api-key","title":"Header-based API Key","text":"<pre><code>{\n  \"authentication\": {\n    \"type\": \"apiKey\",\n    \"in\": \"header\",\n    \"name\": \"Authorization\",\n    \"value\": \"ApiKey your-api-key-here\"\n  }\n}\n</code></pre>"},{"location":"configuration/authentication/#query-parameter-api-key","title":"Query Parameter API Key","text":"<pre><code>{\n  \"authentication\": {\n    \"type\": \"apiKey\",\n    \"in\": \"query\",\n    \"name\": \"api_key\",\n    \"value\": \"your-api-key-here\"\n  }\n}\n</code></pre>"},{"location":"configuration/authentication/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<p>Bearer tokens (commonly used with OAuth2) can be configured as follows:</p> <pre><code>{\n  \"authentication\": {\n    \"type\": \"apiKey\",\n    \"in\": \"header\",\n    \"name\": \"Authorization\",\n    \"value\": \"Bearer your-token-here\"\n  }\n}\n</code></pre>"},{"location":"configuration/authentication/#basic-authentication","title":"Basic Authentication","text":"<p>For APIs that use Basic authentication:</p> <pre><code>{\n  \"authentication\": {\n    \"type\": \"basic\",\n    \"username\": \"your-username\",\n    \"password\": \"your-password\"\n  }\n}\n</code></pre>"},{"location":"configuration/authentication/#using-environment-variables","title":"Using Environment Variables","text":"<p>For added security, you can reference environment variables in your configuration:</p> <pre><code>{\n  \"authentication\": {\n    \"type\": \"apiKey\",\n    \"in\": \"header\",\n    \"name\": \"Authorization\",\n    \"value\": \"Bearer ${API_TOKEN}\"\n  }\n}\n</code></pre> <p>AutoMCP will replace <code>${API_TOKEN}</code> with the value of the <code>API_TOKEN</code> environment variable.</p>"},{"location":"configuration/authentication/#multiple-authentication-methods","title":"Multiple Authentication Methods","text":"<p>Some APIs require multiple authentication methods. You can specify these as an array:</p> <pre><code>{\n  \"authentication\": [\n    {\n      \"type\": \"apiKey\",\n      \"in\": \"header\",\n      \"name\": \"X-API-Key\",\n      \"value\": \"${API_KEY}\"\n    },\n    {\n      \"type\": \"apiKey\",\n      \"in\": \"header\",\n      \"name\": \"X-App-ID\",\n      \"value\": \"${APP_ID}\"\n    }\n  ]\n}\n</code></pre>"},{"location":"configuration/authentication/#auto-detection-from-openapi-specification","title":"Auto-Detection from OpenAPI Specification","text":"<p>AutoMCP can automatically detect authentication requirements from the OpenAPI specification. If your specification includes security schemes, AutoMCP will use them and prompt for necessary values:</p> <pre><code>components:\n  securitySchemes:\n    apiKey:\n      type: apiKey\n      in: header\n      name: X-API-Key\n</code></pre>"},{"location":"configuration/authentication/#best-practices","title":"Best Practices","text":"<ol> <li>Use Environment Variables: Instead of hardcoding credentials, use environment variables</li> <li>Minimum Privileges: Use API keys with the minimum required permissions</li> <li>Separate Keys for Development/Production: Use different keys for different environments</li> <li>Regular Rotation: Regularly rotate API keys and tokens</li> <li>Secure Storage: Keep your <code>.env</code> file or environment variables secure and never commit them to version control </li> </ol>"},{"location":"configuration/mcp/","title":"MCP Server Configuration","text":"<p>The MCP server in AutoMCP can be configured through both the API configuration files and command-line options.</p>"},{"location":"configuration/mcp/#api-configuration","title":"API Configuration","text":"<p>The API configuration file contains settings that are specific to an API and its MCP server. Here are the MCP-related configuration options:</p> <pre><code>{\n  \"name\": \"Example API\",\n  \"description\": \"Example API for demonstration purposes\",\n  \"openapi_spec_url\": \"https://example.com/openapi.json\",\n  \"documentation_url\": \"https://example.com/docs\",\n  \"mcp\": {\n    \"server\": {\n      \"prefix\": \"/api_name\",\n      \"tools_endpoint\": \"/tools\",\n      \"resources_endpoint\": \"/resources\",\n      \"prompts_endpoint\": \"/prompts\"\n    },\n    \"tools\": {\n      \"exclude_operations\": [\"internal_operation\", \"admin_*\"],\n      \"include_operations\": [\"public_*\"],\n      \"summary_truncation\": 120\n    },\n    \"resources\": {\n      \"max_search_results\": 5,\n      \"search_threshold\": 0.7\n    }\n  }\n}\n</code></pre>"},{"location":"configuration/mcp/#mcp-server-options","title":"MCP Server Options","text":"Option Type Description Default <code>prefix</code> string URL prefix for this API's MCP endpoints <code>/api_name</code> <code>tools_endpoint</code> string URL path for the tools endpoint <code>/tools</code> <code>resources_endpoint</code> string URL path for the resources endpoint <code>/resources</code> <code>prompts_endpoint</code> string URL path for the prompts endpoint <code>/prompts</code>"},{"location":"configuration/mcp/#tools-options","title":"Tools Options","text":"Option Type Description Default <code>exclude_operations</code> array Operations to exclude (supports wildcards) <code>[]</code> <code>include_operations</code> array Operations to include (supports wildcards) <code>[]</code> <code>summary_truncation</code> number Maximum length for operation summaries <code>120</code>"},{"location":"configuration/mcp/#resources-options","title":"Resources Options","text":"Option Type Description Default <code>max_search_results</code> number Maximum number of search results to return <code>5</code> <code>search_threshold</code> number Minimum similarity score for search results (0-1) <code>0.7</code>"},{"location":"configuration/mcp/#command-line-configuration","title":"Command-Line Configuration","text":"<p>When starting the MCP server with the CLI, you can provide additional configuration:</p> <pre><code>automcp serve --host 127.0.0.1 --port 8080 --debug\n</code></pre>"},{"location":"configuration/mcp/#cli-options-for-mcp-server","title":"CLI Options for MCP Server","text":"Option Description Default <code>--host</code> Host to bind the server to <code>0.0.0.0</code> <code>--port</code> Port to bind the server to <code>8000</code> <code>--debug</code> Enable debug mode <code>false</code> <code>--config</code> Path to API configuration file or directory None <code>--registry-file</code> Path to the server registry file <code>./automcp_cache/registry.json</code>"},{"location":"configuration/mcp/#multi-api-configuration","title":"Multi-API Configuration","text":"<p>AutoMCP allows you to serve multiple APIs from a single MCP server. Each API has its own set of MCP endpoints under its own prefix.</p> <p>For example, if you have two APIs configured:</p> <ol> <li><code>github</code> API: Endpoints at <code>/github/tools</code>, <code>/github/resources</code>, <code>/github/prompts</code></li> <li><code>twitter</code> API: Endpoints at <code>/twitter/tools</code>, <code>/twitter/resources</code>, <code>/twitter/prompts</code></li> </ol>"},{"location":"configuration/mcp/#claude-configuration-for-multiple-apis","title":"Claude Configuration for Multiple APIs","text":"<p>When generating a Claude configuration file, all registered APIs will be included:</p> <pre><code>automcp install claude --output .claude.json\n</code></pre> <p>This generates:</p> <pre><code>{\n  \"tools\": [\n    {\n      \"name\": \"github\",\n      \"url\": \"http://localhost:8000/github/mcp\",\n      \"schema_version\": \"v1\"\n    },\n    {\n      \"name\": \"twitter\",\n      \"url\": \"http://localhost:8000/twitter/mcp\",\n      \"schema_version\": \"v1\"\n    }\n  ]\n}\n</code></pre>"},{"location":"configuration/pagination/","title":"Pagination","text":"<p>AutoMCP provides automatic pagination support for API endpoints that return multiple records across multiple pages.</p>"},{"location":"configuration/pagination/#pagination-configuration","title":"Pagination Configuration","text":"<p>Configure pagination in your API configuration file:</p> <pre><code>{\n  \"pagination\": {\n    \"enabled\": true,\n    \"mechanism\": \"auto\",\n    \"max_pages\": 5,\n    \"results_field\": \"items\"\n  }\n}\n</code></pre>"},{"location":"configuration/pagination/#pagination-options","title":"Pagination Options","text":"Option Type Description Default <code>enabled</code> boolean Whether pagination is enabled <code>true</code> <code>mechanism</code> string Pagination mechanism (<code>auto</code>, <code>link</code>, <code>cursor</code>, <code>offset</code>, <code>page</code>) <code>auto</code> <code>max_pages</code> number Maximum number of pages to retrieve <code>5</code> <code>results_field</code> string Field containing the array of results <code>\"items\"</code> <p>Additional pagination mechanism-specific options:</p> Option Type Description Default <code>cursor_param</code> string Parameter name for cursor-based pagination <code>\"cursor\"</code> <code>cursor_response_field</code> string Response field containing the next cursor <code>\"next_cursor\"</code> <code>offset_param</code> string Parameter name for offset in offset pagination <code>\"offset\"</code> <code>limit_param</code> string Parameter name for limit in offset pagination <code>\"limit\"</code> <code>page_param</code> string Parameter name for page number in page-based pagination <code>\"page\"</code> <code>page_size_param</code> string Parameter name for page size in page-based pagination <code>\"per_page\"</code>"},{"location":"configuration/pagination/#supported-pagination-mechanisms","title":"Supported Pagination Mechanisms","text":"<p>AutoMCP supports several pagination mechanisms:</p>"},{"location":"configuration/pagination/#link-based-pagination-rfc-5988","title":"Link-Based Pagination (RFC 5988)","text":"<p>Used by GitHub and other APIs, this approach includes pagination links in the response headers:</p> <pre><code>Link: &lt;https://api.example.com/users?page=2&gt;; rel=\"next\", &lt;https://api.example.com/users?page=5&gt;; rel=\"last\"\n</code></pre> <p>Configure with: <pre><code>{\n  \"pagination\": {\n    \"mechanism\": \"link\",\n    \"max_pages\": 5\n  }\n}\n</code></pre></p>"},{"location":"configuration/pagination/#cursor-based-pagination","title":"Cursor-Based Pagination","text":"<p>Uses a cursor or token to fetch the next page:</p> <pre><code>{\n  \"items\": [...],\n  \"next_cursor\": \"dXNlcjpYLWJhc2U2NHVybG9mZnNldA==\"\n}\n</code></pre> <p>Configure with: <pre><code>{\n  \"pagination\": {\n    \"mechanism\": \"cursor\",\n    \"cursor_param\": \"cursor\",\n    \"cursor_response_field\": \"next_cursor\",\n    \"max_pages\": 5\n  }\n}\n</code></pre></p>"},{"location":"configuration/pagination/#offsetlimit-pagination","title":"Offset/Limit Pagination","text":"<p>Uses offset and limit parameters to control pagination:</p> <pre><code>GET /users?offset=50&amp;limit=25\n</code></pre> <p>Configure with: <pre><code>{\n  \"pagination\": {\n    \"mechanism\": \"offset\",\n    \"offset_param\": \"offset\",\n    \"limit_param\": \"limit\",\n    \"max_pages\": 5\n  }\n}\n</code></pre></p>"},{"location":"configuration/pagination/#page-based-pagination","title":"Page-Based Pagination","text":"<p>Uses page numbers and page size:</p> <pre><code>GET /users?page=3&amp;per_page=25\n</code></pre> <p>Configure with: <pre><code>{\n  \"pagination\": {\n    \"mechanism\": \"page\",\n    \"page_param\": \"page\",\n    \"page_size_param\": \"per_page\",\n    \"max_pages\": 5\n  }\n}\n</code></pre></p>"},{"location":"configuration/pagination/#auto-detection","title":"Auto-Detection","text":"<p>When <code>mechanism</code> is set to <code>auto</code>, AutoMCP will automatically detect the pagination mechanism based on:</p> <ol> <li>Presence of Link headers</li> <li>Response structure with cursor fields</li> <li>Support for offset/limit parameters</li> <li>Support for page/per_page parameters</li> </ol> <p>This is the default and works for most APIs.</p>"},{"location":"configuration/pagination/#how-pagination-works-in-automcp","title":"How Pagination Works in AutoMCP","text":"<p>When a tool is executed that returns paginated results:</p> <ol> <li>AutoMCP makes the initial request</li> <li>It detects if more pages are available</li> <li>If more pages exist and <code>max_pages</code> isn't reached, AutoMCP fetches the next page</li> <li>Results from all pages are combined</li> <li>The combined results are returned as a single response</li> </ol>"},{"location":"configuration/pagination/#limiting-result-size","title":"Limiting Result Size","text":"<p>To limit the total number of pages fetched, set the <code>max_pages</code> parameter:</p> <pre><code>{\n  \"pagination\": {\n    \"enabled\": true,\n    \"max_pages\": 3\n  }\n}\n</code></pre> <p>This will fetch at most 3 pages for any paginated endpoint.</p>"},{"location":"configuration/pagination/#disabling-pagination","title":"Disabling Pagination","text":"<p>Pagination can be disabled by setting <code>enabled</code> to <code>false</code>:</p> <pre><code>{\n  \"pagination\": {\n    \"enabled\": false\n  }\n}\n</code></pre>"},{"location":"configuration/pagination/#best-practices","title":"Best Practices","text":"<ol> <li>Set Reasonable Limits: Use <code>max_pages</code> to prevent excessively large responses</li> <li>Use Auto When Possible: The <code>auto</code> mechanism works for most APIs</li> <li>Specify Fields: If your API uses non-standard field names, specify them in the configuration</li> <li>Test Pagination: Verify pagination works correctly for your specific API </li> </ol>"},{"location":"configuration/rate_limiting/","title":"Rate Limiting","text":"<p>AutoMCP includes built-in rate limiting to prevent API throttling and ensure your applications stay within API provider limits.</p>"},{"location":"configuration/rate_limiting/#rate-limiting-configuration","title":"Rate Limiting Configuration","text":"<p>Rate limiting can be configured in your API configuration file:</p> <pre><code>{\n  \"rate_limits\": {\n    \"per_second\": 5,\n    \"per_minute\": 60,\n    \"per_hour\": 1000,\n    \"enabled\": true\n  }\n}\n</code></pre>"},{"location":"configuration/rate_limiting/#available-rate-limit-types","title":"Available Rate Limit Types","text":"<p>AutoMCP supports multiple rate limit windows:</p> Option Type Description <code>per_second</code> number Maximum requests per second <code>per_minute</code> number Maximum requests per minute <code>per_hour</code> number Maximum requests per hour <code>per_day</code> number Maximum requests per day <code>enabled</code> boolean Whether rate limiting is enabled <p>You can specify one or more rate limit windows. AutoMCP will enforce all configured limits.</p>"},{"location":"configuration/rate_limiting/#how-rate-limiting-works","title":"How Rate Limiting Works","text":"<p>AutoMCP uses a token bucket algorithm for rate limiting:</p> <ol> <li>Each rate limit window has a bucket of tokens</li> <li>Tokens are added to the bucket at the configured rate</li> <li>Each API request consumes one token</li> <li>If no tokens are available, the request is delayed until a token becomes available</li> <li>The maximum number of tokens in a bucket equals the rate limit</li> </ol> <p>This approach ensures smooth API usage while preventing bursts that might trigger API provider limits.</p>"},{"location":"configuration/rate_limiting/#rate-limit-behavior","title":"Rate Limit Behavior","text":"<p>When a request would exceed the rate limit:</p> <ol> <li>The request is not dropped but queued</li> <li>AutoMCP will wait until the request can be made within the rate limits</li> <li>If multiple rate limits are configured, the request will wait for all limits to be satisfied</li> </ol>"},{"location":"configuration/rate_limiting/#configuring-multiple-rate-limits","title":"Configuring Multiple Rate Limits","text":"<p>For APIs with complex rate limiting requirements, you can specify multiple limits:</p> <pre><code>{\n  \"rate_limits\": {\n    \"per_second\": 5,\n    \"per_minute\": 100,\n    \"per_hour\": 1000,\n    \"enabled\": true\n  }\n}\n</code></pre> <p>This configuration enforces: - No more than 5 requests per second - No more than 100 requests per minute - No more than 1000 requests per hour</p>"},{"location":"configuration/rate_limiting/#disabling-rate-limiting","title":"Disabling Rate Limiting","text":"<p>Rate limiting can be disabled by setting <code>enabled</code> to <code>false</code>:</p> <pre><code>{\n  \"rate_limits\": {\n    \"per_minute\": 60,\n    \"enabled\": false\n  }\n}\n</code></pre> <p>You can also omit the <code>rate_limits</code> section entirely to disable rate limiting.</p>"},{"location":"configuration/rate_limiting/#best-practices","title":"Best Practices","text":"<ol> <li>Check API Documentation: Review the API provider's rate limits and configure accordingly</li> <li>Add Buffer Space: Set slightly lower limits than the API allows to account for other applications using the same API key</li> <li>Start Conservative: Begin with conservative limits and increase as needed</li> <li>Monitor Usage: Keep track of rate limit responses from the API to adjust your configuration </li> </ol>"},{"location":"configuration/retry/","title":"Retry Handling","text":"<p>AutoMCP includes built-in retry functionality to handle transient errors and temporary API failures automatically.</p>"},{"location":"configuration/retry/#retry-configuration","title":"Retry Configuration","text":"<p>Configure retry behavior in your API configuration file:</p> <pre><code>{\n  \"retry\": {\n    \"max_retries\": 3,\n    \"backoff_factor\": 0.5,\n    \"retry_on_status_codes\": [429, 500, 502, 503, 504],\n    \"enabled\": true\n  }\n}\n</code></pre>"},{"location":"configuration/retry/#configuration-options","title":"Configuration Options","text":"Option Type Description Default <code>max_retries</code> number Maximum number of retry attempts <code>3</code> <code>backoff_factor</code> number Exponential backoff multiplier <code>0.5</code> <code>retry_on_status_codes</code> array HTTP status codes to trigger retries <code>[429, 500, 502, 503, 504]</code> <code>enabled</code> boolean Whether retry functionality is enabled <code>true</code>"},{"location":"configuration/retry/#how-retry-works","title":"How Retry Works","text":"<p>When a request fails with a status code in <code>retry_on_status_codes</code>:</p> <ol> <li>AutoMCP waits for a delay period</li> <li>The request is retried</li> <li>If the request fails again, the delay increases exponentially</li> <li>This continues until either:</li> <li>The request succeeds</li> <li>The maximum number of retries is reached</li> <li>A non-retryable error occurs</li> </ol>"},{"location":"configuration/retry/#exponential-backoff","title":"Exponential Backoff","text":"<p>The delay between retries follows an exponential backoff pattern:</p> <pre><code>delay = backoff_factor * (2 ^ (retry_number - 1))\n</code></pre> <p>For example, with a <code>backoff_factor</code> of 0.5: - First retry: 0.5 seconds - Second retry: 1.0 seconds - Third retry: 2.0 seconds</p> <p>This strategy helps prevent overwhelming the API server during outages or rate limit issues.</p>"},{"location":"configuration/retry/#retry-status-codes","title":"Retry Status Codes","text":"<p>By default, AutoMCP retries on these status codes:</p> <ul> <li><code>429</code>: Too Many Requests (rate limiting)</li> <li><code>500</code>: Internal Server Error</li> <li><code>502</code>: Bad Gateway</li> <li><code>503</code>: Service Unavailable</li> <li><code>504</code>: Gateway Timeout</li> </ul> <p>You can customize this list to match the specific behavior of your API.</p>"},{"location":"configuration/retry/#retry-headers","title":"Retry Headers","text":"<p>AutoMCP also respects standard retry headers sent by the server:</p> <ul> <li><code>Retry-After</code>: If present, AutoMCP will wait the specified number of seconds</li> <li><code>X-RateLimit-Reset</code>: Used by some APIs to indicate when rate limits will reset</li> </ul>"},{"location":"configuration/retry/#disabling-retry","title":"Disabling Retry","text":"<p>Retry functionality can be disabled by setting <code>enabled</code> to <code>false</code>:</p> <pre><code>{\n  \"retry\": {\n    \"max_retries\": 3,\n    \"enabled\": false\n  }\n}\n</code></pre> <p>You can also omit the <code>retry</code> section entirely to use default retry behavior.</p>"},{"location":"configuration/retry/#best-practices","title":"Best Practices","text":"<ol> <li>Start Conservative: Begin with lower <code>max_retries</code> and increase if needed</li> <li>Tune for Your API: Adjust <code>backoff_factor</code> based on the API's rate limits and recovery patterns</li> <li>Add Specific Status Codes: Include any additional status codes that your API returns for retryable errors</li> <li>Avoid Retrying Client Errors: Generally, don't retry 4xx errors (except 429) as they typically indicate client-side problems </li> </ol>"},{"location":"development/contributing/","title":"Contributing to AutoMCP","text":"<p>Thank you for your interest in contributing to AutoMCP! This guide will help you get started with contributing to the project.</p>"},{"location":"development/contributing/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<ol> <li> <p>Fork and clone the repository:    <pre><code>git clone https://github.com/yourusername/AutoMCP.git\ncd AutoMCP\n</code></pre></p> </li> <li> <p>Install in development mode:    <pre><code>pip install -e \".[dev]\"\n</code></pre></p> </li> <li> <p>Install development dependencies:    <pre><code>pip install pytest pytest-cov black isort mypy\n</code></pre></p> </li> </ol>"},{"location":"development/contributing/#code-style","title":"Code Style","text":"<p>AutoMCP follows these code style guidelines:</p> <ul> <li>Black for code formatting</li> <li>isort for import sorting</li> <li>mypy for static type checking</li> <li>PEP 8 for code style</li> <li>Google Python Style Guide for docstrings</li> </ul> <p>You can automatically format your code with:</p> <pre><code>black src tests\nisort src tests\n</code></pre>"},{"location":"development/contributing/#testing","title":"Testing","text":"<p>Run tests with pytest:</p> <pre><code>pytest\n</code></pre> <p>For coverage report:</p> <pre><code>pytest --cov=src\n</code></pre>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li> <p>Create a new branch for your feature or bugfix:    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes and commit them:    <pre><code>git commit -m \"Add feature X\"\n</code></pre></p> </li> <li> <p>Push to your fork:    <pre><code>git push origin feature/your-feature-name\n</code></pre></p> </li> <li> <p>Open a pull request against the <code>main</code> branch of the original repository</p> </li> </ol>"},{"location":"development/contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<ul> <li>Include tests for new features or bug fixes</li> <li>Update documentation if necessary</li> <li>Follow the code style guidelines</li> <li>Keep pull requests focused on a single topic</li> <li>Write clear commit messages</li> </ul>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<p>When adding new features, please update the relevant documentation:</p> <ol> <li>Update or add docstrings for public classes and methods</li> <li>Update the relevant documentation in the <code>docs/</code> directory</li> <li>Add examples if appropriate</li> </ol>"},{"location":"development/contributing/#feature-requests-and-bug-reports","title":"Feature Requests and Bug Reports","text":"<p>For feature requests or bug reports, please open an issue on GitHub with a clear description of the feature or bug.</p>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing to AutoMCP, you agree that your contributions will be licensed under the project's license. </p>"},{"location":"development/testing/","title":"Testing Guide","text":"<p>AutoMCP uses pytest for testing. This guide explains how to run tests and add new ones.</p>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":"<p>To run all tests:</p> <pre><code>pytest\n</code></pre> <p>To run tests with coverage:</p> <pre><code>pytest --cov=src\n</code></pre> <p>To run specific test files:</p> <pre><code>pytest tests/test_specific_file.py\n</code></pre> <p>To run specific test functions:</p> <pre><code>pytest tests/test_specific_file.py::test_specific_function\n</code></pre>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":"<p>Tests are organized by module:</p> <ul> <li><code>tests/test_main.py</code>: Tests for the CLI functionality</li> <li><code>tests/test_manager.py</code>: Tests for server management</li> <li><code>tests/test_utils.py</code>: Tests for utility functions</li> <li><code>tests/openapi/</code>: Tests for OpenAPI modules</li> <li><code>tests/mcp/</code>: Tests for MCP server modules</li> <li><code>tests/documentation/</code>: Tests for documentation modules</li> <li><code>tests/prompt/</code>: Tests for prompt modules</li> </ul>"},{"location":"development/testing/#writing-tests","title":"Writing Tests","text":"<p>When adding new features, create corresponding test files. Here's an example test:</p> <pre><code>import pytest\nfrom src.utils import ServerRegistry\n\ndef test_add_server():\n    # Setup\n    registry = ServerRegistry(registry_file=\":memory:\")\n\n    # Exercise\n    registry.add_server(\"test_api\", \"test_config.json\", \"test_db_dir\")\n\n    # Verify\n    servers = registry.list_servers()\n    assert len(servers) == 1\n    assert servers[0][\"name\"] == \"test_api\"\n    assert servers[0][\"config_path\"] == \"test_config.json\"\n    assert servers[0][\"db_directory\"] == \"test_db_dir\"\n</code></pre>"},{"location":"development/testing/#using-fixtures","title":"Using Fixtures","text":"<p>Use pytest fixtures for common setup:</p> <pre><code>import pytest\nfrom src.utils import ServerRegistry\n\n@pytest.fixture\ndef registry():\n    \"\"\"Create an in-memory registry for testing.\"\"\"\n    return ServerRegistry(registry_file=\":memory:\")\n\ndef test_add_server(registry):\n    registry.add_server(\"test_api\", \"test_config.json\", \"test_db_dir\")\n    servers = registry.list_servers()\n    assert len(servers) == 1\n</code></pre>"},{"location":"development/testing/#mocking-external-services","title":"Mocking External Services","text":"<p>Use the <code>unittest.mock</code> module or <code>pytest-mock</code> to mock external services:</p> <pre><code>from unittest.mock import patch, MagicMock\n\ndef test_process_config():\n    # Mock HTTP response for OpenAPI spec\n    mock_response = MagicMock()\n    mock_response.json.return_value = {\"openapi\": \"3.0.0\", \"info\": {\"title\": \"Test API\"}}\n    mock_response.status_code = 200\n\n    with patch(\"requests.get\", return_value=mock_response):\n        config = process_config(\"config.json\")\n        assert config.name == \"Test API\"\n</code></pre>"},{"location":"development/testing/#testing-the-cli","title":"Testing the CLI","text":"<p>To test CLI commands, use the <code>CliRunner</code> from the <code>click.testing</code> module:</p> <pre><code>from click.testing import CliRunner\nfrom src.main import main\n\ndef test_list_servers_command():\n    runner = CliRunner()\n    result = runner.invoke(main, [\"list-servers\"])\n    assert result.exit_code == 0\n    assert \"No API servers registered\" in result.output\n</code></pre>"},{"location":"development/testing/#testing-standards","title":"Testing Standards","text":"<ul> <li>Each module should have at least 80% test coverage</li> <li>Test both success and failure cases</li> <li>Test edge cases and boundary conditions</li> <li>Use meaningful assertions that help diagnose failures</li> </ul>"},{"location":"development/testing/#continuous-integration","title":"Continuous Integration","text":"<p>Tests are run automatically on GitHub Actions for every pull request. Ensure your tests pass locally before submitting a PR. </p>"},{"location":"getting-started/about-mcp/","title":"About MCP","text":"<p>The Model Context Protocol (MCP) is a standardized way for Large Language Models (LLMs) to interact with external tools and services. AutoMCP implements MCP servers for your APIs, making them accessible to LLMs.</p>"},{"location":"getting-started/about-mcp/#what-is-mcp","title":"What is MCP?","text":"<p>MCP provides a structured interface for LLMs to:</p> <ol> <li>Discover available tools and capabilities</li> <li>Execute operations on external systems</li> <li>Retrieve contextual information</li> <li>Access predefined prompts and templates</li> </ol>"},{"location":"getting-started/about-mcp/#automcps-mcp-implementation","title":"AutoMCP's MCP Implementation","text":"<p>AutoMCP creates MCP-compliant servers that expose three main endpoints:</p>"},{"location":"getting-started/about-mcp/#tools","title":"Tools","text":"<p>The <code>tools</code> endpoint allows LLMs to interact with your API's operations:</p> <ul> <li>List Tools: Discover available API endpoints</li> <li>Call Tool: Execute specific API operations with parameters</li> </ul>"},{"location":"getting-started/about-mcp/#resources","title":"Resources","text":"<p>The <code>resources</code> endpoint provides access to documentation:</p> <ul> <li>List Resources: Get a list of all indexed documentation pages</li> <li>Call Resource: Retrieve the content of a specific documentation page</li> <li>Search: Perform semantic search across the documentation</li> </ul>"},{"location":"getting-started/about-mcp/#prompts","title":"Prompts","text":"<p>The <code>prompts</code> endpoint manages predefined prompts:</p> <ul> <li>List Prompts: View available prompts defined in the configuration</li> <li>Call Prompt: Retrieve the content of a specific prompt</li> </ul>"},{"location":"getting-started/about-mcp/#mcp-server-architecture","title":"MCP Server Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               MCP Server                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    Tools    \u2502  Resources  \u2502   Prompts   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502           FastAPI Application           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u25b2                 \u25b2\n             \u2502                 \u2502\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n  \u2502   OpenAPI Toolkit   \u2502     \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n             \u25b2                \u2502\n             \u2502                \u2502\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n  \u2502  OpenAPI Spec Parser\u2502    \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n                             \u2502\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502   Documentation Manager   \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u25b2\n             \u2502\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 Documentation Crawler\u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"getting-started/about-mcp/#detailed-mcp-endpoint-specifications","title":"Detailed MCP Endpoint Specifications","text":"<p>AutoMCP provides a complete MCP server implementation with three main endpoints: Tools, Resources, and Prompts. The following sections detail the API specifications for each endpoint.</p>"},{"location":"getting-started/about-mcp/#tools-endpoint","title":"Tools Endpoint","text":"<p>The Tools endpoint allows LLMs to discover and call API operations.</p>"},{"location":"getting-started/about-mcp/#list-tools","title":"List Tools","text":"<p>Retrieves a list of all available tools from the API.</p> <p>Request: <pre><code>GET /tools\n</code></pre></p> <p>Response: <pre><code>{\n  \"tools\": [\n    {\n      \"name\": \"get_user\",\n      \"description\": \"Get a user by ID\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"user_id\": {\n            \"type\": \"string\",\n            \"description\": \"The ID of the user\"\n          }\n        },\n        \"required\": [\"user_id\"]\n      }\n    },\n    {\n      \"name\": \"list_repositories\",\n      \"description\": \"List repositories for a user\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"username\": {\n            \"type\": \"string\",\n            \"description\": \"The username to list repositories for\"\n          },\n          \"per_page\": {\n            \"type\": \"integer\",\n            \"description\": \"Number of results per page\"\n          }\n        },\n        \"required\": [\"username\"]\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"getting-started/about-mcp/#call-tool","title":"Call Tool","text":"<p>Executes a specific tool with the provided parameters.</p> <p>Request: <pre><code>POST /tools/call\nContent-Type: application/json\n\n{\n  \"name\": \"get_user\",\n  \"parameters\": {\n    \"user_id\": \"12345\"\n  }\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"result\": {\n    \"id\": \"12345\",\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\"\n  }\n}\n</code></pre></p>"},{"location":"getting-started/about-mcp/#resources-endpoint","title":"Resources Endpoint","text":"<p>The Resources endpoint provides access to API documentation.</p>"},{"location":"getting-started/about-mcp/#list-resources","title":"List Resources","text":"<p>Retrieves a list of all indexed documentation resources.</p> <p>Request: <pre><code>GET /resources\n</code></pre></p> <p>Response: <pre><code>{\n  \"resources\": [\n    {\n      \"uri\": \"getting-started\",\n      \"title\": \"Getting Started with the API\"\n    },\n    {\n      \"uri\": \"authentication\",\n      \"title\": \"Authentication Guide\"\n    },\n    {\n      \"uri\": \"endpoints/users\",\n      \"title\": \"Users API Reference\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"getting-started/about-mcp/#call-resource","title":"Call Resource","text":"<p>Retrieves the content of a specific documentation resource.</p> <p>Request: <pre><code>POST /resources/call\nContent-Type: application/json\n\n{\n  \"uri\": \"authentication\"\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"content\": \"# Authentication Guide\\n\\nTo authenticate with our API, you need to provide an API key in the Authorization header...\",\n  \"metadata\": {\n    \"title\": \"Authentication Guide\",\n    \"last_updated\": \"2023-09-15\"\n  }\n}\n</code></pre></p>"},{"location":"getting-started/about-mcp/#search-resources","title":"Search Resources","text":"<p>Performs a semantic search across documentation.</p> <p>Request: <pre><code>POST /resources/search\nContent-Type: application/json\n\n{\n  \"query\": \"How do I authenticate?\",\n  \"limit\": 3\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"results\": [\n    {\n      \"uri\": \"authentication\",\n      \"title\": \"Authentication Guide\",\n      \"content\": \"# Authentication Guide\\n\\nTo authenticate with our API, you need to provide an API key...\",\n      \"score\": 0.95\n    },\n    {\n      \"uri\": \"api-keys\",\n      \"title\": \"Managing API Keys\",\n      \"content\": \"# Managing API Keys\\n\\nAPI keys can be generated in your account settings...\",\n      \"score\": 0.82\n    },\n    {\n      \"uri\": \"getting-started\",\n      \"title\": \"Getting Started\",\n      \"content\": \"# Getting Started\\n\\nBefore making API calls, you'll need to authenticate...\",\n      \"score\": 0.76\n    }\n  ]\n}\n</code></pre></p>"},{"location":"getting-started/about-mcp/#prompts-endpoint","title":"Prompts Endpoint","text":"<p>The Prompts endpoint manages predefined prompts.</p>"},{"location":"getting-started/about-mcp/#list-prompts","title":"List Prompts","text":"<p>Retrieves a list of all available prompts.</p> <p>Request: <pre><code>GET /prompts\n</code></pre></p> <p>Response: <pre><code>{\n  \"prompts\": [\n    {\n      \"id\": \"usage_example\",\n      \"description\": \"Example of how to use the API\"\n    },\n    {\n      \"id\": \"error_handling\",\n      \"description\": \"How to handle common errors\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"getting-started/about-mcp/#call-prompt","title":"Call Prompt","text":"<p>Retrieves the content of a specific prompt.</p> <p>Request: <pre><code>POST /prompts/call\nContent-Type: application/json\n\n{\n  \"id\": \"usage_example\"\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"content\": \"Here's how to use the API effectively:\\n\\n1. First, authenticate...\",\n  \"metadata\": {\n    \"description\": \"Example of how to use the API\"\n  }\n}\n</code></pre></p>"},{"location":"getting-started/about-mcp/#usage-in-llms","title":"Usage in LLMs","text":"<p>LLMs like Claude that support the MCP protocol can directly interact with your MCP server. After configuration, the LLM can:</p> <ol> <li>Discover your API's capabilities</li> <li>Call endpoints with appropriate parameters </li> <li>Search documentation for context</li> <li>Use predefined prompts for consistent interactions </li> </ol>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>AutoMCP can be installed using pip, the Python package manager. Follow the steps below to get started.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or higher</li> <li>pip (Python package manager)</li> </ul>"},{"location":"getting-started/installation/#installing-from-pypi","title":"Installing from PyPI","text":"<p>The recommended way to install AutoMCP is through pip:</p> <pre><code>pip install automcp\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For development or the latest features, you can install AutoMCP directly from the GitHub repository:</p> <pre><code>git clone https://github.com/jroakes/AutoMCP.git\ncd AutoMCP\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify that AutoMCP is correctly installed by running:</p> <pre><code>automcp --help\n</code></pre> <p>You should see output listing the available commands and options.</p>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>AutoMCP automatically installs several dependencies:</p> <ul> <li><code>fastapi</code>: For serving the MCP API</li> <li><code>uvicorn</code>: ASGI server for FastAPI</li> <li><code>pydantic</code>: Data validation and settings management</li> <li><code>requests</code>: HTTP requests library</li> <li><code>PyYAML</code>: YAML parsing for configuration files</li> <li><code>chromadb</code>: Vector database for documentation storage</li> <li><code>colorama</code>: Terminal text coloring</li> </ul>"},{"location":"getting-started/installation/#configuration","title":"Configuration","text":"<p>After installation, you'll need to create configuration files for the APIs you want to expose. See the Configuration Guides for details. </p>"},{"location":"getting-started/quick_start/","title":"Getting Started with AutoMCP","text":"<p>This guide will walk you through the basic steps to get AutoMCP up and running.</p>"},{"location":"getting-started/quick_start/#quick-start","title":"Quick Start","text":"<pre><code># Install AutoMCP\n# Clone the repository and install dependencies\ngit clone https://github.com/jroakes/automcp.git\ncd automcp\npip install -r requirements.txt\n\n# Add an API configuration\npython -m src.main add --config your_api_config.json\n\n# Start the MCP server\npython -m src.main serve\n</code></pre>"},{"location":"getting-started/quick_start/#basic-workflow","title":"Basic Workflow","text":"<p>The workflow for using AutoMCP typically involves these steps:</p> <ol> <li>Create a configuration file for your API</li> <li>Add the API to AutoMCP</li> <li>Start the MCP server</li> <li>Connect your LLM to the MCP endpoints</li> </ol>"},{"location":"getting-started/quick_start/#creating-an-api-configuration","title":"Creating an API Configuration","text":"<p>Create a JSON file with your API configuration. At minimum, you need to include:</p> <pre><code>{\n  \"name\": \"Your API Name\",\n  \"description\": \"A description of what your API does\",\n  \"openapi_spec_url\": \"https://example.com/openapi.json\",\n  \"documentation_url\": \"https://example.com/docs\"\n}\n</code></pre>"},{"location":"getting-started/quick_start/#advanced-configuration-options","title":"Advanced Configuration Options","text":"<p>For more control, you can add:</p> <pre><code>{\n  \"name\": \"Your API Name\",\n  \"description\": \"A description of what your API does\",\n  \"openapi_spec_url\": \"https://example.com/openapi.json\",\n  \"documentation_url\": \"https://example.com/docs\",\n  \"authentication\": {\n    \"type\": \"apiKey\",\n    \"in\": \"header\",\n    \"name\": \"Authorization\",\n    \"value\": \"Bearer ${API_KEY}\"\n  },\n  \"rate_limits\": {\n    \"per_minute\": 60,\n    \"enabled\": true\n  },\n  \"retry\": {\n    \"max_retries\": 3,\n    \"backoff_factor\": 0.5,\n    \"enabled\": true\n  },\n  \"db_directory\": \"./your_api_db\",\n  \"crawl\": {\n    \"max_depth\": 3,\n    \"max_pages\": 100\n  },\n  \"prompts\": [\n    {\n      \"name\": \"example_prompt\",\n      \"description\": \"An example prompt for the API\",\n      \"content\": \"Here is how to use the API effectively...\"\n    }\n  ]\n}\n</code></pre>"},{"location":"getting-started/quick_start/#adding-an-api-to-automcp","title":"Adding an API to AutoMCP","text":"<p>Once you have your configuration file, add it to AutoMCP:</p> <pre><code>python -m src.main add --config your_api_config.json\n</code></pre> <p>For multiple APIs in a directory:</p> <pre><code>python -m src.main add --config ./api_configs/\n</code></pre> <p>This will: 1. Process the OpenAPI specification 2. Crawl the documentation 3. Set up the vector database for documentation search 4. Register the API in AutoMCP's registry</p>"},{"location":"getting-started/quick_start/#checking-registered-apis","title":"Checking Registered APIs","text":"<p>To list the APIs registered with AutoMCP:</p> <pre><code>python -m src.main list-servers\n</code></pre>"},{"location":"getting-started/quick_start/#starting-the-mcp-server","title":"Starting the MCP Server","text":"<p>To start the MCP server:</p> <pre><code>python -m src.main serve\n</code></pre> <p>This will start a server on http://0.0.0.0:8000 by default.</p> <p>Options: <pre><code>python -m src.main serve --host 127.0.0.1 --port 8080 --debug\n</code></pre></p>"},{"location":"getting-started/quick_start/#integrating-with-claude","title":"Integrating with Claude","text":"<p>To generate a configuration file for Claude:</p> <pre><code>python -m src.main install claude --output .claude.json\n</code></pre> <p>This creates a Claude-compatible configuration file that you can use to integrate your MCP server with Claude. </p>"}]}